<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>防治率計算器｜多處理 × 重複 × 年度折線圖</title>
  <style>
    :root {
      --bg: #0f172a; /* slate-900 */
      --panel: #111827; /* gray-900 */
      --panel-2: #0b1220;
      --text: #e5e7eb; /* gray-200 */
      --muted: #9ca3af; /* gray-400 */
      --accent: #22c55e; /* green-500 */
      --border: #1f2937; /* gray-800 */
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: linear-gradient(180deg, var(--bg), #060a14 60%);
      color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial,
      "Noto Sans", "Liberation Sans", sans-serif; line-height: 1.5;
    }
    header { padding: 20px 24px; border-bottom: 1px solid var(--border); position: sticky; top:0; background: rgba(15,23,42,.85); backdrop-filter: blur(6px); }
    h1 { margin: 0; font-size: 20px; letter-spacing: .5px; }
    main { padding: 20px 24px 80px; max-width: 1200px; margin: 0 auto; }

    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .card { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border: 1px solid var(--border); border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
      margin-bottom: 16px; }
    label { font-size: 13px; color: var(--muted); }
    input[type="number"], input[type="text"] { background: #0b1220; color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 8px 10px; width: 110px; }
    input[type="number"]::-webkit-outer-spin-button,input[type="number"]::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }

    button { background: #1f2937; border: 1px solid var(--border); color: var(--text); padding: 10px 14px; border-radius: 12px; cursor: pointer; transition: .15s ease; }
    button:hover { transform: translateY(-1px); border-color: #334155; }
    button.primary { background: var(--accent); color: #06290f; border-color: #16a34a; font-weight: 600; }
    button.ghost { background: transparent; }

    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { border: 1px solid var(--border); padding: 6px 8px; text-align: center; }
    th { background: #0b1324; position: sticky; top: 0; z-index: 1; }

    .muted { color: var(--muted); }
    .note { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .badge { font-size: 12px; color: #0b1324; background: #86efac; padding: 2px 8px; border-radius: 999px; margin-left: 8px; }

    .legend { display: flex; flex-wrap: wrap; gap: 8px 12px; align-items: center; margin-top: 8px; }
    .legend-item { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; color: var(--muted); }
    .swatch { width: 14px; height: 14px; border-radius: 3px; }

    canvas { width: 100%; height: 420px; background: #0a0f1c; border: 1px solid var(--border); border-radius: 16px; }
    .scroll-x { overflow-x: auto; }
    .sticky-actions { position: sticky; bottom: 0; background: rgba(11,18,32,.9); backdrop-filter: blur(6px); padding: 10px; display:flex; gap:8px; border:1px solid var(--border); border-radius:12px; }
  </style>
</head>
<body>
  <header>
    <h1>防治率計算器 <span class="badge">(X+0.5)½ 轉換 + 折線圖</span></h1>
  </header>
  <main>
    <section class="card">
      <div class="row" style="gap:16px">
        <div>
          <label>處理組數量</label><br>
          <input id="treatments" type="number" min="1" value="3">
        </div>
        <div>
          <label>重複數（含對照）</label><br>
          <input id="replicates" type="number" min="1" value="3">
        </div>
        <div>
          <label>時間點數量（例如：月份）</label><br>
          <input id="timepoints" type="number" min="1" value="12">
        </div>
        <div>
          <label>時間點前綴（可空白）</label><br>
          <input id="tpPrefix" type="text" placeholder="例：月">
        </div>
        <div class="row">
          <button id="btnBuild" class="primary">產生輸入表格</button>
          <button id="btnDemo">填入示範資料</button>
          <button id="btnCalc">計算防治率 & 繪圖</button>
          <button id="btnCSV" class="ghost">匯出 CSV</button>
          <button id="btnPNG" class="ghost">下載圖表 PNG</button>
        </div>
      </div>
      <p class="note">轉換：<code>(X + 0.5)<sup>1/2</sup></code>；防治率（%）＝ <code>(1 − 平均處理區(轉換後) / 平均對照區(轉換後)) × 100</code>。若對照平均為 0（轉換後）則該時間點無法計算，會以 <code>—</code> 顯示並在圖上略過。</p>
    </section>

    <section class="card">
      <h3 style="margin:0 0 8px">輸入資料</h3>
      <div id="tableHost" class="scroll-x"></div>
    </section>

    <section class="card">
      <h3 style="margin:0 0 8px">計算結果</h3>
      <div id="resultHost" class="scroll-x"></div>
    </section>
    
    <section class="card">
      <h3 style="margin:0 0 8px">年度防治率折線圖</h3>
      <canvas id="chartCanvas" width="900" height="420"></canvas>
      <div id="legend" class="legend"></div>
    </section>

  </main>

  <script>
    // ====== 公用函式 ======
    const $ = (sel) => document.querySelector(sel);
    const clamp = (v, a, b) => Math.min(Math.max(v, a), b);
    const trans = (x) => Math.sqrt((Number(x) || 0) + 0.5); // (X+0.5)^{1/2}
    const mean = (arr) => arr.length ? arr.reduce((a,b)=>a+b,0) / arr.length : NaN;
    const round2 = (v) => (isFinite(v) ? Math.round(v * 100) / 100 : v);

    // 色板（最多 12 組處理）
    function colorFor(i){
      const hue = (i * 43 + 10) % 360; // 分散色相
      return `hsl(${hue} 70% 55%)`;
    }

    // ====== 動態建立輸入表格 ======
    function buildTable(){
      const T = parseInt($('#treatments').value)||1;
      const R = parseInt($('#replicates').value)||1;
      const N = parseInt($('#timepoints').value)||1;
      const prefix = ($('#tpPrefix').value || '').trim();

      let html = '<div class="note" style="margin-bottom:6px">每個時間點皆需填入 <b>對照</b>與<b>各處理</b>的<b>重複</b>蟲數（未轉換原始值）。</div>';
      html += '<table><thead><tr><th>時間點</th>';
      for(let r=1;r<=R;r++) html += `<th>對照-重複${r}</th>`;
      for(let t=1;t<=T;t++){
        for(let r=1;r<=R;r++) html += `<th>處理${t}-重複${r}</th>`;
      }
      html += '</tr></thead><tbody>';
      for(let i=1;i<=N;i++){
        const label = prefix? `${i}${prefix}` : `${i}`;
        html += `<tr><td>${label}</td>`;
        for(let r=1;r<=R;r++) html += `<td><input type="number" step="any" id="ctrl_${i}_${r}" value="0"/></td>`;
        for(let t=1;t<=T;t++){
          for(let r=1;r<=R;r++) html += `<td><input type="number" step="any" id="t${t}_${i}_${r}" value="0"/></td>`;
        }
        html += '</tr>';
      }
      html += '</tbody></table>';
      $('#tableHost').innerHTML = html;
      $('#resultHost').innerHTML = '';
      clearChart();
    }

    // ====== 讀取輸入、計算、防治率表 ======
    function compute(){
      const T = parseInt($('#treatments').value)||1;
      const R = parseInt($('#replicates').value)||1;
      const N = parseInt($('#timepoints').value)||1;
      const prefix = ($('#tpPrefix').value || '').trim();

      const labels = Array.from({length:N}, (_,i)=> prefix? `${i+1}${prefix}` : `${i+1}`);

      // 轉換後的平均（對照、處理）
      const ctrlAvg = new Array(N).fill(NaN);
      const trAvg = Array.from({length:T}, ()=> new Array(N).fill(NaN));

      for(let i=1;i<=N;i++){
        const ctrlVals = [];
        for(let r=1;r<=R;r++) ctrlVals.push(trans( $('#ctrl_'+i+'_'+r)?.value ));
        ctrlAvg[i-1] = mean(ctrlVals);
        for(let t=1;t<=T;t++){
          const vals = [];
          for(let r=1;r<=R;r++) vals.push(trans( $('#t'+t+'_'+i+'_'+r)?.value ));
          trAvg[t-1][i-1] = mean(vals);
        }
      }

      // 防治率
      const eff = Array.from({length:T}, ()=> new Array(N).fill(null));
      for(let t=0;t<T;t++){
        for(let i=0;i<N;i++){
          const c = ctrlAvg[i];
          const a = trAvg[t][i];
          if(!isFinite(c) || c <= 0){ eff[t][i] = null; continue; }
          eff[t][i] = round2((1 - a / c) * 100);
        }
      }

      // 結果表
      let html = '<div class="note" style="margin-bottom:6px">顯示的是以 <b>(X+0.5)½</b> 轉換後取平均，再代入公式所得之防治率（%）。</div>';
      html += '<table><thead><tr><th>時間點</th><th>對照平均(轉換後)</th>';
      for(let t=1;t<=T;t++) html += `<th>處理${t} 防治率(%)</th>`;
      html += '</tr></thead><tbody>';
      for(let i=0;i<N;i++){
        html += `<tr><td>${labels[i]}</td><td>${isFinite(ctrlAvg[i])? round2(ctrlAvg[i]) : '—'}</td>`;
        for(let t=0;t<T;t++) html += `<td>${eff[t][i]===null? '—' : eff[t][i]}</td>`;
        html += '</tr>';
      }
      html += '</tbody></table>';
      $('#resultHost').innerHTML = html;

      // 繪圖
      const series = [];
      for(let t=0;t<T;t++) series.push({ name: `處理${t+1}`, data: eff[t] });
      drawChart(labels, series);

      // 給 CSV / 下載用暫存
      window.__calcCache = { labels, ctrlAvg, eff, series };
    }

    // ====== 匯出 CSV ======
    function exportCSV(){
      const cache = window.__calcCache;
      if(!cache){ alert('請先計算再匯出。'); return; }
      const { labels, ctrlAvg, series } = cache;
      const header = ['時間點','對照平均(轉換後)', ...series.map(s=>s.name+' 防治率(%)')];
      const rows = [header];
      for(let i=0;i<labels.length;i++){
        rows.push([labels[i], round2(ctrlAvg[i])].concat(series.map(s => s.data[i] ?? '')));
      }
      const csv = rows.map(r => r.join(',')).join('\n');
      const blob = new Blob(["\uFEFF" + csv], {type:'text/csv;charset=utf-8;'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'control-efficacy.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // ====== 下載 PNG ======
    function downloadPNG(){
      const c = $('#chartCanvas');
      const a = document.createElement('a');
      a.href = c.toDataURL('image/png');
      a.download = 'efficacy-chart.png';
      a.click();
    }

    // ====== 自製折線圖（無外掛、離線可用） ======
    function clearChart(){
      const ctx = $('#chartCanvas').getContext('2d');
      ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    }

    function drawChart(labels, series){
      const canvas = $('#chartCanvas');
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      ctx.clearRect(0,0,W,H);

      // 邊界與座標軸
      const m = { l: 60, r: 20, t: 18, b: 40 };

      // 收集數值（忽略 null）
      const vals = [];
      series.forEach(s => s.data.forEach(v => { if(v!==null && isFinite(v)) vals.push(v); }));
      let yMin = vals.length ? Math.min(...vals) : 0;
      let yMax = vals.length ? Math.max(...vals) : 100;
      yMin = Math.min(0, yMin);
      yMax = Math.max(100, yMax);
      const pad = (yMax - yMin) * 0.08;
      yMin -= pad; yMax += pad; if(yMax === yMin){ yMax = yMin + 1; }

      const X = (i) => m.l + (W - m.l - m.r) * (i / (labels.length - 1 || 1));
      const Y = (v) => m.t + (H - m.t - m.b) * (1 - (v - yMin) / (yMax - yMin));

      // 背景網格
      ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 1;
      ctx.beginPath();
      const yTicks = 5;
      for(let k=0;k<=yTicks;k++){
        const yv = yMin + (yMax - yMin) * (k / yTicks);
        const yy = Y(yv);
        ctx.moveTo(m.l, yy); ctx.lineTo(W - m.r, yy);
      }
      ctx.stroke();

      // 軸線
      ctx.strokeStyle = '#334155'; ctx.lineWidth = 1.5; ctx.beginPath();
      ctx.moveTo(m.l, m.t); ctx.lineTo(m.l, H - m.b); // y
      ctx.moveTo(m.l, H - m.b); ctx.lineTo(W - m.r, H - m.b); // x
      ctx.stroke();

      // y刻度文字
      ctx.fillStyle = '#9ca3af'; ctx.font = '12px system-ui,ui-sans-serif'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      for(let k=0;k<=yTicks;k++){
        const yv = yMin + (yMax - yMin) * (k / yTicks);
        const yy = Y(yv);
        ctx.fillText(Math.round(yv), m.l - 8, yy);
      }

      // x標籤
      ctx.textAlign = 'center'; ctx.textBaseline = 'top';
      const step = Math.ceil(labels.length / 12); // 最多顯示12個label
      labels.forEach((lb, i) => {
        if(i % step === 0) ctx.fillText(lb, X(i), H - m.b + 8);
      });

      // 畫線與點
      series.forEach((s, si) => {
        const color = colorFor(si);
        ctx.lineWidth = 2; ctx.strokeStyle = color; ctx.beginPath();
        let first = true;
        s.data.forEach((v,i)=>{
          if(v===null || !isFinite(v)) return;
          const x = X(i), y = Y(v);
          if(first){ ctx.moveTo(x,y); first=false; } else { ctx.lineTo(x,y); }
        });
        ctx.stroke();
        // 點
        s.data.forEach((v,i)=>{
          if(v===null || !isFinite(v)) return;
          const x = X(i), y = Y(v);
          ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
        });
      });

      // y軸標題
      ctx.save();
      ctx.translate(18, H/2); ctx.rotate(-Math.PI/2);
      ctx.fillStyle = '#cbd5e1'; ctx.font = '12px system-ui,ui-sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
      ctx.fillText('防治率 (%)', 0, 0);
      ctx.restore();

      // 圖例
      const legend = $('#legend'); legend.innerHTML = '';
      series.forEach((s, si) => {
        const el = document.createElement('div'); el.className = 'legend-item';
        const sw = document.createElement('span'); sw.className = 'swatch'; sw.style.background = colorFor(si);
        const tx = document.createElement('span'); tx.textContent = s.name;
        el.appendChild(sw); el.appendChild(tx); legend.appendChild(el);
      });
    }

    // ====== 示範資料（產生可視化趨勢） ======
    function fillDemo(){
      // 若尚未建立表格，就先建立
      if(!$('#tableHost').querySelector('table')) buildTable();
      const T = parseInt($('#treatments').value)||1;
      const R = parseInt($('#replicates').value)||1;
      const N = parseInt($('#timepoints').value)||1;
      // 讓對照整年略有波動、處理組隨時間提升防效
      for(let i=1;i<=N;i++){
        const baseCtrl = 24 + Math.round(6*Math.sin(i/2));
        for(let r=1;r<=R;r++) $('#ctrl_'+i+'_'+r).value = Math.max(0, Math.round(baseCtrl + (Math.random()*6-3)));
        for(let t=1;t<=T;t++){
          for(let r=1;r<=R;r++){
            const drift = (t*3) + (i*0.6); // 隨時間與處理強度略增
            const val = Math.max(0, Math.round(baseCtrl - drift + (Math.random()*6-3)));
            $('#t'+t+'_'+i+'_'+r).value = val;
          }
        }
      }
    }

    // ====== 事件繫結（避免 inline onclick 的全域汙染問題） ======
    window.addEventListener('DOMContentLoaded', () => {
      $('#btnBuild').addEventListener('click', buildTable);
      $('#btnDemo').addEventListener('click', fillDemo);
      $('#btnCalc').addEventListener('click', compute);
      $('#btnCSV').addEventListener('click', exportCSV);
      $('#btnPNG').addEventListener('click', downloadPNG);

      // 預設先建一份表格以免使用者看不到輸入區
      buildTable();
    });
  </script>
</body>
</html>
