<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>é˜²æ²»ç‡è¨ˆç®—å™¨ï½œå¤šè™•ç† Ã— é‡è¤‡ Ã— å¹´åº¦åœ–è¡¨</title>
  <style>
    :root {
      --bg: #0f172a; /* slate-900 */
      --panel: #111827; /* gray-900 */
      --panel-2: #0b1220;
      --text: #e5e7eb; /* gray-200 */
      --muted: #9ca3af; /* gray-400 */
      --accent: #22c55e; /* green-500 */
      --border: #1f2937; /* gray-800 */
      --ghost-color: var(--text);
      --ghost-border: var(--border);
      --ghost-hover-border: #334155;
      --font-size-base: 16px;
      --font-size-sm: 14px;
      --font-size-xs: 12px;
    }
    body.light-mode {
      --bg: #f8fafc;
      --panel: #ffffff;
      --panel-2: #f1f5f9;
      --text: #1f2937;
      --muted: #6b7280;
      --accent: #16a34a;
      --border: #e2e8f0;
      --ghost-color: var(--muted);
      --ghost-border: #cbd5e1;
      --ghost-hover-border: #94a3b8;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: linear-gradient(180deg, var(--bg), #060a14 60%);
      color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial,
      "Noto Sans", "Liberation Sans", sans-serif; line-height: 1.5; font-size: var(--font-size-base);
    }
    body.light-mode { background: #f1f5f9; }
    header { padding: 24px; border-bottom: 1px solid var(--border); position: sticky; top:0; background: rgba(15,23,42,.85); backdrop-filter: blur(6px); display: flex; align-items: center; justify-content: space-between;}
    body.light-mode header { background: rgba(255,255,255,.85); }
    h1 { margin: 0; font-size: 24px; letter-spacing: .5px; }
    main { padding: 24px; max-width: 1400px; margin: 0 auto; display: block; }

    .row { display: flex; flex-wrap: wrap; gap: 16px; align-items: center; }
    .card { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border: 1px solid var(--border); border-radius: 16px; padding: 24px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
      margin-bottom: 16px; }
    body.light-mode .card { box-shadow: 0 4px 12px rgba(0,0,0,.08); }
    label { font-size: var(--font-size-sm); color: var(--muted); }
    input { background: var(--panel-2); color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 10px 12px; width: 120px; font-size: var(--font-size-sm); }
    input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
    
    .button-group { display: flex; gap: 12px; flex-wrap: wrap; }

    button { background: #1f2937; border: 1px solid var(--border); color: var(--text); padding: 12px 16px; border-radius: 12px; cursor: pointer; transition: .15s ease; font-size: var(--font-size-sm); }
    button:hover { transform: translateY(-1px); border-color: #334155; }
    button.primary { background: var(--accent); color: #06290f; border-color: #16a34a; font-weight: 600; }
    button.ghost { background: transparent; color: var(--ghost-color); border-color: var(--ghost-border); }
    button.ghost:hover { border-color: var(--ghost-hover-border); }
    button.ghost:active { transform: translateY(0); }

    table { width: 100%; border-collapse: collapse; font-size: var(--font-size-sm); }
    th, td { border: 1px solid var(--border); padding: 8px 10px; text-align: center; }
    th { background: var(--panel-2); position: sticky; top: 0; z-index: 1; }
    body.light-mode th { background: #e2e8f0; }
    .treatment-group { background: #1c273a; }
    body.light-mode .treatment-group { background: #eff6ff; }
    .treatment-group:nth-child(even) { background: #16202f; }
    body.light-mode .treatment-group:nth-child(even) { background: #e2e8f0; }
    .stats-header { background: #0c1a2c; font-size: var(--font-size-xs); color: #a4b2c8; white-space: nowrap; }
    body.light-mode .stats-header { background: #dde2ec; color: #6b7280; }
    .muted { color: var(--muted); }
    .note { font-size: var(--font-size-sm); color: var(--muted); margin-top: 8px; }
    .badge { font-size: var(--font-size-sm); color: #0b1324; background: #86efac; padding: 4px 10px; border-radius: 999px; margin-left: 10px; }
    body.light-mode .badge { background: #bbf7d0; }

    .legend { display: flex; flex-wrap: wrap; gap: 8px 12px; align-items: center; margin-top: 8px; }
    .legend-item { display: inline-flex; align-items: center; gap: 6px; font-size: var(--font-size-sm); color: var(--muted); }
    .swatch { width: 16px; height: 16px; border-radius: 4px; }

    canvas { max-width: 100%; height: auto; background: var(--panel-2); border: 1px solid var(--border); border-radius: 16px; }
    .chart-container { position: relative; width: 100%; height: 500px; }
    .scroll-x { overflow-x: auto; }
    .sticky-actions { position: sticky; bottom: 0; background: rgba(11,18,32,.9); backdrop-filter: blur(6px); padding: 10px; display:flex; gap:8px; border:1px solid var(--border); border-radius:12px; }
    .chart-type-selector { margin-bottom: 12px; }
    .chart-type-selector label { font-size: var(--font-size-sm); margin-right: 8px; }
    sup { color: var(--accent); font-weight: bold; font-size: 1em; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body class="light-mode">
  <header>
    <h1>é˜²æ²»ç‡è¨ˆç®—å™¨ <span class="badge">(X+0.5)Â½ è½‰æ› + åœ–è¡¨</span></h1>
    <button id="themeToggle" class="ghost" style="padding: 6px 10px;">åˆ‡æ›ä¸»é¡Œ</button>
  </header>
  <main>
    <section class="card">
      <div class="row" style="gap:20px">
        <div>
          <label>è™•ç†çµ„æ•¸é‡</label><br>
          <input id="treatments" type="number" min="1" value="3">
        </div>
        <div>
          <label>é‡è¤‡æ•¸ï¼ˆå«å°ç…§ï¼‰</label><br>
          <input id="replicates" type="number" min="1" value="3">
        </div>
        <div>
          <label>æ™‚é–“é»æ•¸é‡</label><br>
          <input id="timepoints" type="number" min="1" value="12">
        </div>
        <div>
          <label>æ™‚é–“é»å‰ç¶´</label><br>
          <input id="tpPrefix" type="text" placeholder="ä¾‹ï¼šæœˆ">
        </div>
      </div>
      <div class="row" style="margin-top: 20px; justify-content: flex-start;">
        <div class="button-group">
          <button id="btnBuild" class="primary">ç”¢ç”Ÿè¼¸å…¥è¡¨æ ¼</button>
          <button id="btnDemo" class="ghost">å¡«å…¥ç¤ºç¯„è³‡æ–™</button>
          <button id="btnCalc" class="primary">è¨ˆç®—é˜²æ²»ç‡ & ç¹ªåœ–</button>
        </div>
<div class="button-group">
          <button id="btnImport" class="ghost">åŒ¯å…¥ CSV</button>
          <button id="btnDemoCSV" class="ghost">ä¸‹è¼‰ç¤ºç¯„ CSV</button>
          <button id="btnCSV" class="ghost">åŒ¯å‡º CSV</button>
          <button id="btnReport" class="ghost">åŒ¯å‡º PDF å ±å‘Š</button>
          <button id="btnPNG" class="ghost">ä¸‹è¼‰åœ–è¡¨ PNG</button>
          <input type="file" id="fileInput" accept=".csv" style="display:none;">
        </div>
      </div>
      <div id="treatmentNames" style="margin-top:20px"></div>
      <p class="note" style="font-size:var(--font-size-base)">è½‰æ›ï¼š<code>(X + 0.5)<sup>1/2</sup></code>ï¼›é˜²æ²»ç‡ï¼ˆ%ï¼‰ï¼ <code>(1 âˆ’ å¹³å‡è™•ç†å€(è½‰æ›å¾Œ) / å¹³å‡å°ç…§å€(è½‰æ›å¾Œ)) Ã— 100</code>ã€‚è‹¥å°ç…§å¹³å‡ç‚º 0ï¼ˆè½‰æ›å¾Œï¼‰å‰‡è©²æ™‚é–“é»ç„¡æ³•è¨ˆç®—ï¼Œæœƒä»¥ <code>â€”</code> é¡¯ç¤ºä¸¦åœ¨åœ–ä¸Šç•¥éã€‚</p>
    </section>

    <section class="card">
      <h3 style="margin:0 0 12px">è¼¸å…¥è³‡æ–™</h3>
      <div id="tableHost" class="scroll-x"></div>
    </section>

    <section class="card">
      <h3 style="margin:0 0 12px">è¨ˆç®—çµæœ</h3>
      <div id="resultHost" class="scroll-x"></div>
      <p class="note" style="margin-top: 16px; font-size:var(--font-size-sm)">çµæœè¡¨æ ¼ä¸­ï¼Œé˜²æ²»ç‡å¾Œçš„ **\*** è™Ÿè¡¨ç¤ºè©²è™•ç†çµ„èˆ‡å°ç…§çµ„åœ¨è©²æ™‚é–“é»ï¼Œä»¥ t-test æª¢å®šå…·æœ‰é¡¯è‘—å·®ç•° (p-value &lt; 0.05)ã€‚</p>
    </section>

    <section class="card">
      <h3 style="margin:0 0 12px">å¹´åº¦é˜²æ²»ç‡åœ–è¡¨</h3>
      <div class="chart-type-selector">
        <label for="chartType">é¸æ“‡åœ–è¡¨é¡å‹ï¼š</label>
        <select id="chartType" style="padding:6px 8px; font-size: var(--font-size-sm); border-radius: 8px;">
          <option value="line">æŠ˜ç·šåœ–</option>
          <option value="bar">é•·æ¢åœ–</option>
        </select>
      </div>
      <div class="chart-container">
        <canvas id="chartCanvas"></canvas>
      </div>
    </section>
  </main>

  <script>
    // ====== å…¬ç”¨å‡½å¼ ======
    const $ = (sel) => document.querySelector(sel);
    const trans = (x) => Math.sqrt((Number(x) || 0) + 0.5);
    const round2 = (v) => (isFinite(v) ? Math.round(v * 100) / 100 : v);
    const round1 = (v) => (isFinite(v) ? Math.round(v * 10) / 10 : v);

    function colorFor(i) {
        const colors = ['#22c55e', '#ef4444', '#3b82f6', '#f97316', '#a855f7', '#14b8a6', '#f59e0b', '#d946ef', '#6366f1', '#ec4899', '#84cc16', '#6b7280'];
        return colors[i % colors.length];
    }
    
    function buildInputs() {
        buildTreatmentNames();
        buildTable();
    }

    function buildTreatmentNames() {
        const T = parseInt($('#treatments').value) || 1;
        const host = $('#treatmentNames');
        let html = '<div class="row" style="gap:16px"><p style="font-size:var(--font-size-sm);color:var(--muted);margin:0;align-self:flex-end;white-space:nowrap">è™•ç†çµ„åç¨±ï¼š</p>';
        for (let t = 1; t <= T; t++) {
            html += `<div><label>è™•ç†${t}</label><br><input type="text" id="tName_${t}" value="è™•ç†${t}" style="width:100px"/></div>`;
        }
        html += '</div>';
        host.innerHTML = html;
    }

    function getTreatmentNames() {
        const T = parseInt($('#treatments').value) || 1;
        const names = [];
        for (let t = 1; t <= T; t++) {
            names.push($(`#tName_${t}`).value || `è™•ç†${t}`);
        }
        return names;
    }

    function buildTable() {
        const T = parseInt($('#treatments').value) || 1;
        const R = parseInt($('#replicates').value) || 1;
        const N = parseInt($('#timepoints').value) || 1;
        const prefix = ($('#tpPrefix').value || '').trim();
        const names = getTreatmentNames();

        let html = '<div class="note" style="margin-bottom:8px">æ¯å€‹æ™‚é–“é»çš†éœ€å¡«å…¥ <b>å°ç…§</b>èˆ‡<b>å„è™•ç†</b>çš„<b>é‡è¤‡</b>èŸ²æ•¸ï¼ˆæœªè½‰æ›åŸå§‹å€¼ï¼‰ã€‚</div>';
        html += '<table><thead><tr><th>æ™‚é–“é»</th>';
        for (let r = 1; r <= R; r++) html += `<th class="control-group">å°ç…§-é‡è¤‡${r}</th>`;
        for (let t = 0; t < T; t++) {
            for (let r = 1; r <= R; r++) html += `<th class="treatment-group t-${t}"><span>${names[t]}</span>-é‡è¤‡${r}</th>`;
        }
        html += '</tr></thead><tbody>';
        for (let i = 1; i <= N; i++) {
            const label = prefix ? `${i}${prefix}` : `${i}`;
            html += `<tr data-row="${i}"><td>${label}</td>`;
            for (let r = 1; r <= R; r++) html += `<td class="control-group"><input type="text" id="ctrl_${i}_${r}" placeholder=""/></td>`;
            for (let t = 1; t <= T; t++) {
                for (let r = 1; r <= R; r++) html += `<td class="treatment-group"><input type="text" id="t${t}_${i}_${r}" placeholder=""/></td>`;
            }
            html += '</tr>';
        }
        html += '</tbody></table>';
        $('#tableHost').innerHTML = html;
        $('#resultHost').innerHTML = '';
        clearChart();
        setupTableNavigation();
    }

    function setupTableNavigation() {
        const inputs = $('#tableHost').querySelectorAll('input');
        inputs.forEach((input, index) => {
            input.addEventListener('keydown', (e) => {
                const T = parseInt($('#treatments').value) || 1;
                const R = parseInt($('#replicates').value) || 1;
                const cols = (T * R) + R;
                const col = (index % cols);

                let nextIndex = index;
                if (e.key === 'ArrowRight' || (e.key === 'Tab' && !e.shiftKey)) {
                    e.preventDefault();
                    nextIndex = (index + 1) % inputs.length;
                } else if (e.key === 'ArrowLeft' || (e.key === 'Tab' && e.shiftKey)) {
                    e.preventDefault();
                    nextIndex = (index - 1 + inputs.length) % inputs.length;
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    nextIndex = (index + cols) % inputs.length;
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    nextIndex = (index - cols + inputs.length) % inputs.length;
                }
                inputs[nextIndex].focus();
            });
        });
    }

    function compute() {
        const T = parseInt($('#treatments').value) || 1;
        const R = parseInt($('#replicates').value) || 1;
        const N = parseInt($('#timepoints').value) || 1;
        const prefix = ($('#tpPrefix').value || '').trim();
        const names = getTreatmentNames();
        const labels = Array.from({ length: N }, (_, i) => prefix ? `${i + 1}${prefix}` : `${i + 1}`);

        const ctrlDataTransformed = Array.from({ length: N }, () => []);
        const trDataTransformed = Array.from({ length: T }, () => Array.from({ length: N }, () => []));

        for (let i = 1; i <= N; i++) {
            for (let r = 1; r <= R; r++) {
                const ctrlVal = trans($('#ctrl_' + i + '_' + r)?.value);
                if(isFinite(ctrlVal)) ctrlDataTransformed[i - 1].push(ctrlVal);
                
                for (let t = 1; t <= T; t++) {
                    const trVal = trans($('#t' + t + '_' + i + '_' + r)?.value);
                    if(isFinite(trVal)) trDataTransformed[t - 1][i - 1].push(trVal);
                }
            }
        }

        const stats = {
            ctrlAvg: [],
            ctrlSd: [],
            ctrlCv: [],
            trAvg: Array.from({ length: T }, () => []),
            trSd: Array.from({ length: T }, () => []),
            trCv: Array.from({ length: T }, () => []),
            eff: Array.from({ length: T }, () => []),
            isSignificant: Array.from({ length: T }, () => [])
        };
        
        for (let i = 0; i < N; i++) {
            const ctrlData = ctrlDataTransformed[i].filter(v => isFinite(v));
            stats.ctrlAvg[i] = ctrlData.length > 0 ? ss.mean(ctrlData) : NaN;
            stats.ctrlSd[i] = ctrlData.length > 1 ? ss.standardDeviation(ctrlData) : NaN;
            stats.ctrlCv[i] = stats.ctrlSd[i] / stats.ctrlAvg[i] * 100;
            
            for (let t = 0; t < T; t++) {
                const trData = trDataTransformed[t][i].filter(v => isFinite(v));
                stats.trAvg[t][i] = trData.length > 0 ? ss.mean(trData) : NaN;
                stats.trSd[t][i] = trData.length > 1 ? ss.standardDeviation(trData) : NaN;
                stats.trCv[t][i] = stats.trSd[t][i] / stats.trAvg[t][i] * 100;

                const c = stats.ctrlAvg[i];
                const a = stats.trAvg[t][i];
                stats.eff[t][i] = (isFinite(c) && c > 0) ? round2((1 - a / c) * 100) : null;

                stats.isSignificant[t][i] = false;
                if (ctrlData.length >= 2 && trData.length >= 2) {
                    try {
                        const tTestResult = ss.tTestTwoSample(ctrlData, trData);
                        if (tTestResult.pValue < 0.05) {
                            stats.isSignificant[t][i] = true;
                        }
                    } catch (e) {
                        console.warn('t-test failed for data points:', ctrlData, trData);
                    }
                }
            }
        }
        
        let html = '<div class="note" style="margin-bottom:8px">é¡¯ç¤ºçš„æ˜¯ä»¥ <b>(X+0.5)Â½</b> è½‰æ›å¾Œä¹‹çµ±è¨ˆæ•¸æ“šèˆ‡é˜²æ²»ç‡ï¼ˆ%ï¼‰ã€‚</div>';
        html += '<table><thead><tr><th rowspan="2">æ™‚é–“é»</th><th colspan="3" class="stats-header">å°ç…§çµ„ (è½‰æ›å¾Œ)</th>';
        for (let t = 0; t < T; t++) html += `<th colspan="2" class="stats-header">${names[t]} (è½‰æ›å¾Œ)</th>`;
        html += '</tr><tr>';
        html += '<th class="stats-header">å¹³å‡å€¼</th><th class="stats-header">æ¨™æº–å·®</th><th class="stats-header">è®Šç•°ä¿‚æ•¸(%)</th>';
        for (let t = 0; t < T; t++) html += '<th class="stats-header">é˜²æ²»ç‡(%)</th><th class="stats-header">è®Šç•°ä¿‚æ•¸(%)</th>';
        html += '</tr></thead><tbody>';
        
        for (let i = 0; i < N; i++) {
            html += `<tr><td>${labels[i]}</td>`;
            html += `<td>${isFinite(stats.ctrlAvg[i]) ? round2(stats.ctrlAvg[i]) : 'â€”'}</td><td>${isFinite(stats.ctrlSd[i]) ? round2(stats.ctrlSd[i]) : 'â€”'}</td><td>${isFinite(stats.ctrlCv[i]) ? round1(stats.ctrlCv[i]) : 'â€”'}</td>`;
            for (let t = 0; t < T; t++) {
                const effText = (stats.eff[t][i] === null ? 'â€”' : stats.eff[t][i]);
                const significantMark = (stats.isSignificant[t][i] ? '<sup>*</sup>' : '');
                html += `<td>${effText}${significantMark}</td><td>${isFinite(stats.trCv[t][i]) ? round1(stats.trCv[t][i]) : 'â€”'}</td>`;
            }
            html += '</tr>';
        }
        html += '</tbody></table>';
        $('#resultHost').innerHTML = html;

        const datasets = [];
        for (let t = 0; t < T; t++) {
            datasets.push({
                label: names[t],
                data: stats.eff[t],
                borderColor: colorFor(t),
                backgroundColor: colorFor(t),
                tension: 0, 
                pointRadius: $('#chartType').value === 'line' ? 5 : 0,
                pointBorderWidth: 2,
                pointBackgroundColor: colorFor(t),
                pointHoverRadius: 7,
                pointHoverBorderWidth: 2
            });
        }
        drawChart(labels, datasets);
        window.__calcCache = { labels, ctrlAvg: stats.ctrlAvg, eff: stats.eff, datasets, stats };
    }
function downloadDemoCSV() {
        const header = ['æ™‚é–“é»', 'å°ç…§-é‡è¤‡1', 'å°ç…§-é‡è¤‡2', 'å°ç…§-é‡è¤‡3', 'è™•ç†1-é‡è¤‡1', 'è™•ç†1-é‡è¤‡2', 'è™•ç†1-é‡è¤‡3', 'è™•ç†2-é‡è¤‡1', 'è™•ç†2-é‡è¤‡2', 'è™•ç†2-é‡è¤‡3', 'è™•ç†3-é‡è¤‡1', 'è™•ç†3-é‡è¤‡2', 'è™•ç†3-é‡è¤‡3'];
        const rows = [header];
        
        // ç”Ÿæˆ 12 å€‹æœˆçš„ç¤ºç¯„æ•¸æ“š
        for (let i = 1; i <= 12; i++) {
            const baseCtrl = 24 + Math.round(6 * Math.sin(i / 2));
            const row = [`${i}æœˆ`];
            
            // å°ç…§çµ„æ•¸æ“š
            for (let r = 0; r < 3; r++) {
                row.push(Math.max(0, Math.round(baseCtrl + (Math.random() * 6 - 3))));
            }
            
            // å„è™•ç†çµ„æ•¸æ“š
            for (let t = 1; t <= 3; t++) {
                for (let r = 0; r < 3; r++) {
                    const drift = (t * 3) + (i * 0.6);
                    const val = Math.max(0, Math.round(baseCtrl - drift + (Math.random() * 6 - 3)));
                    row.push(val);
                }
            }
            rows.push(row);
        }
        
        const csv = rows.map(r => r.join(',')).join('\n');
        const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'é˜²æ²»ç‡è¨ˆç®—å™¨-ç¤ºç¯„æ•¸æ“š.csv';
        a.click();
        URL.revokeObjectURL(a.href);
    }

  function exportReport() {
    const cache = window.__calcCache;
    if (!cache) { 
        alert('è«‹å…ˆè¨ˆç®—å†åŒ¯å‡ºå ±å‘Šã€‚'); 
        return; 
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'mm', 'a4');
    
    const { labels, stats } = cache;
    const names = getTreatmentNames();
    const T = parseInt($('#treatments').value) || 1;
    const R = parseInt($('#replicates').value) || 1;
    const N = parseInt($('#timepoints').value) || 1;
    const prefix = ($('#tpPrefix').value || '').trim();
    
    let yPos = 15;
    const pageHeight = 297;
    const margin = 15;
    const pageWidth = 210;
    const contentWidth = pageWidth - (2 * margin);
    
    // è¼”åŠ©å‡½æ•¸ - æª¢æŸ¥æ˜¯å¦éœ€è¦æ–°é é¢
    function checkPageBreak(requiredHeight) {
        if (yPos + requiredHeight > pageHeight - 20) {
            doc.addPage();
            yPos = margin;
            return true;
        }
        return false;
    }
    
    // è¼”åŠ©å‡½æ•¸ - ç¹ªè£½åˆ†éš”ç·š
    function drawSeparator() {
        doc.setDrawColor(220, 220, 220);
        doc.setLineWidth(0.3);
        doc.line(margin, yPos, pageWidth - margin, yPos);
        yPos += 5;
    }
    
    // === å°é¢è¨­è¨ˆ ===
    // æ¼¸è®ŠèƒŒæ™¯æ•ˆæœ
    for(let i = 0; i < 25; i++) {
        const alpha = 1 - (i / 25) * 0.3;
        const green = Math.floor(34 + (i * 2));
        doc.setFillColor(34, Math.min(139, green), 34);
        doc.rect(0, i, pageWidth, 1, 'F');
    }
    
    // ä¸»æ¨™é¡Œ
    doc.setFontSize(24);
    doc.setTextColor(255, 255, 255);
    const titleText = 'CONTROL EFFICACY ANALYSIS';
    const titleWidth = doc.getTextWidth(titleText);
    doc.text(titleText, (pageWidth - titleWidth) / 2, 18);
    
    yPos = 35;
    
    // å‰¯æ¨™é¡Œ
    doc.setFontSize(16);
    doc.setTextColor(34, 139, 34);
    const subtitleText = 'Prevention Efficacy Calculator Report';
    const subtitleWidth = doc.getTextWidth(subtitleText);
    doc.text(subtitleText, (pageWidth - subtitleWidth) / 2, yPos);
    
    // è£é£¾æ€§åˆ†éš”ç·š
    yPos += 8;
    doc.setDrawColor(34, 139, 34);
    doc.setLineWidth(1.5);
    const lineStart = (pageWidth - 160) / 2;
    doc.line(lineStart, yPos, lineStart + 160, yPos);
    
    yPos += 15;
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    const dateText = `Report Generated: ${new Date().toLocaleString('en-US')}`;
    const dateWidth = doc.getTextWidth(dateText);
    doc.text(dateText, (pageWidth - dateWidth) / 2, yPos);
    
    yPos += 25;
    
    // === å¯¦é©—åƒæ•¸å€å¡Š ===
    const paramBoxHeight = 45;
    doc.setFillColor(248, 249, 250);
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.5);
    doc.roundedRect(margin, yPos - 5, contentWidth, paramBoxHeight, 5, 5, 'FD');
    
    // å€å¡Šæ¨™é¡Œ
    doc.setFontSize(14);
    doc.setTextColor(34, 139, 34);
    doc.text('ğŸ“Š EXPERIMENTAL DESIGN', margin + 10, yPos + 8);
    
    yPos += 18;
    
    // åƒæ•¸å¡ç‰‡å¼æ’åˆ—
    doc.setFontSize(10);
    const params = [
        ['Treatments:', `${T} groups`, 'ğŸ§ª'],
        ['Replicates:', `${R} per group`, 'ğŸ”„'],
        ['Time Points:', `${N} measurements`, 'ğŸ“…'],
        ['Time Prefix:', `${prefix || 'None'}`, 'ğŸ·ï¸']
    ];
    
    const cardWidth = (contentWidth - 30) / 2;
    params.forEach(([key, value, icon], index) => {
        const col = index % 2;
        const row = Math.floor(index / 2);
        const xOffset = col * (cardWidth + 10);
        const yOffset = row * 12;
        
        // åƒæ•¸å¡ç‰‡èƒŒæ™¯
        doc.setFillColor(255, 255, 255);
        doc.roundedRect(margin + 10 + xOffset, yPos + yOffset - 2, cardWidth, 10, 2, 2, 'F');
        
        doc.setTextColor(80, 80, 80);
        doc.text(`${icon} ${key}`, margin + 15 + xOffset, yPos + yOffset + 3);
        doc.setTextColor(0, 0, 0);
        doc.setFont(undefined, 'bold');
        doc.text(value, margin + 15 + xOffset + doc.getTextWidth(`${icon} ${key} `), yPos + yOffset + 3);
        doc.setFont(undefined, 'normal');
    });
    
    yPos += 35;
    
    // === è™•ç†çµ„è³‡è¨Š ===
    checkPageBreak(30 + Math.ceil(names.length / 3) * 15);
    
    doc.setFontSize(14);
    doc.setTextColor(34, 139, 34);
    doc.text('ğŸ§¬ TREATMENT GROUPS', margin, yPos);
    
    yPos += 10;
    drawSeparator();
    
    // è™•ç†çµ„ä»¥å¡ç‰‡æ–¹å¼æ’åˆ—
    const groupsPerRow = Math.min(3, Math.floor(contentWidth / 55));
    const cardWidthGroup = (contentWidth - (groupsPerRow - 1) * 5) / groupsPerRow;
    
    names.forEach((name, i) => {
        const col = i % groupsPerRow;
        const row = Math.floor(i / groupsPerRow);
        const xOffset = col * (cardWidthGroup + 5);
        const yOffset = row * 16;
        
        if (yPos + yOffset > pageHeight - 40) {
            doc.addPage();
            yPos = margin;
        }
        
        // è™•ç†çµ„å¡ç‰‡
        doc.setFillColor(245, 245, 245);
        doc.setDrawColor(34, 139, 34);
        doc.setLineWidth(0.3);
        doc.roundedRect(margin + xOffset, yPos + yOffset, cardWidthGroup, 12, 2, 2, 'FD');
        
        // è™•ç†çµ„æ¨™ç±¤
        doc.setFillColor(34, 139, 34);
        doc.circle(margin + xOffset + 6, yPos + yOffset + 6, 3, 'F');
        
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(8);
        doc.setFont(undefined, 'bold');
        const labelText = `T${i + 1}`;
        const labelWidth = doc.getTextWidth(labelText);
        doc.text(labelText, margin + xOffset + 6 - labelWidth/2, yPos + yOffset + 7);
        
        // è™•ç†çµ„åç¨±
        doc.setTextColor(0, 0, 0);
        doc.setFontSize(9);
        doc.setFont(undefined, 'normal');
        const englishName = name.replace(/è™•ç†/g, 'Treatment').replace(/å°ç…§/g, 'Control');
        const maxNameWidth = cardWidthGroup - 18;
        let displayName = englishName;
        if (doc.getTextWidth(displayName) > maxNameWidth) {
            displayName = displayName.substring(0, Math.floor(maxNameWidth / 3)) + '...';
        }
        doc.text(displayName, margin + xOffset + 12, yPos + yOffset + 7);
    });
    
    yPos += Math.ceil(names.length / groupsPerRow) * 16 + 15;
    
    // === åœ–è¡¨å€å¡Š ===
    if (typeof chart !== 'undefined' && chart) {
        doc.addPage(); // åœ–è¡¨ç¨ç«‹ä¸€é 
        yPos = margin;
        
        // åœ–è¡¨æ¨™é¡Œ
        doc.setFillColor(34, 139, 34);
        doc.rect(0, 0, pageWidth, 25, 'F');
        doc.setFontSize(18);
        doc.setTextColor(255, 255, 255);
        const chartTitle = 'ğŸ“ˆ EFFICACY TRENDS';
        const chartTitleWidth = doc.getTextWidth(chartTitle);
        doc.text(chartTitle, (pageWidth - chartTitleWidth) / 2, 17);
        
        yPos = 35;
        
        try {
            const chartCanvas = document.getElementById('chartCanvas');
            if (chartCanvas) {
                const chartImage = chartCanvas.toDataURL('image/png', 1.0);
                
                // è¨ˆç®—åœ–è¡¨æœ€ä½³å°ºå¯¸ (ä¿æŒæ¯”ä¾‹)
                const maxWidth = contentWidth;
                const maxHeight = 160; // å›ºå®šé«˜åº¦é¿å…æ“ å£“
                
                // åœ–è¡¨å®¹å™¨èƒŒæ™¯
                doc.setFillColor(255, 255, 255);
                doc.setDrawColor(220, 220, 220);
                doc.setLineWidth(1);
                doc.roundedRect(margin, yPos, maxWidth, maxHeight + 10, 5, 5, 'FD');
                
                // åœ–è¡¨æ¨™é¡ŒèƒŒæ™¯
                doc.setFillColor(248, 249, 250);
                doc.roundedRect(margin, yPos, maxWidth, 15, 5, 5, 'F');
                
                doc.setFontSize(10);
                doc.setTextColor(80, 80, 80);
                doc.text('Treatment Efficacy Over Time', margin + 5, yPos + 10);
                
                // åµŒå…¥åœ–è¡¨ (å›ºå®šå°ºå¯¸é¿å…è®Šå½¢)
                doc.addImage(chartImage, 'PNG', margin + 5, yPos + 20, maxWidth - 10, maxHeight - 15);
                
                yPos += maxHeight + 20;
                
                // åœ–è¡¨èªªæ˜
                doc.setFontSize(8);
                doc.setTextColor(120, 120, 120);
                doc.text('* Efficacy calculated as (1 - Treatment/Control) Ã— 100%. Higher values indicate better control.', margin, yPos);
                
            }
        } catch (error) {
            console.warn('Cannot add chart to PDF:', error);
            doc.setFontSize(12);
            doc.setTextColor(200, 100, 100);
            const errorText = 'âš ï¸ Chart embedding failed - please check digital version';
            const errorWidth = doc.getTextWidth(errorText);
            doc.text(errorText, (pageWidth - errorWidth) / 2, yPos + 50);
        }
    }
    
    // === çµ±è¨ˆçµæœè¡¨æ ¼ (æ–°é é¢) ===
    doc.addPage();
    yPos = margin;
    
    // è¡¨æ ¼æ¨™é¡Œé çœ‰
    doc.setFillColor(34, 139, 34);
    doc.rect(0, 0, pageWidth, 25, 'F');
    doc.setFontSize(18);
    doc.setTextColor(255, 255, 255);
    const tableTitle = 'ğŸ“‹ STATISTICAL RESULTS';
    const tableTitleWidth = doc.getTextWidth(tableTitle);
    doc.text(tableTitle, (pageWidth - tableTitleWidth) / 2, 17);
    
    yPos = 35;
    
    // å‹•æ…‹è¨ˆç®—è¡¨æ ¼åˆ—å¯¬
    const totalCols = 3 + (T * 2);
    const availableWidth = contentWidth - 4; // ç•™å‡ºé‚Šè·
    const minColWidth = 18;
    const maxColWidth = 30;
    let colWidth = Math.min(maxColWidth, Math.max(minColWidth, availableWidth / totalCols));
    const actualTableWidth = colWidth * totalCols;
    const tableStartX = margin + (contentWidth - actualTableWidth) / 2; // å±…ä¸­å°é½Š
    
    // è¡¨æ ¼å¤–æ¡†
    doc.setDrawColor(34, 139, 34);
    doc.setLineWidth(1);
    doc.rect(tableStartX - 2, yPos - 2, actualTableWidth + 4, 14, 'S');
    
    // è¡¨æ ¼æ¨™é¡Œè¡ŒèƒŒæ™¯
    doc.setFillColor(34, 139, 34);
    doc.rect(tableStartX, yPos, actualTableWidth, 12, 'F');
    
    // è¡¨æ ¼æ¨™é¡Œ
    doc.setFontSize(8);
    doc.setTextColor(255, 255, 255);
    doc.setFont(undefined, 'bold');
    
    const headers = ['Time Point', 'Control Avg', 'Control CV%'];
    names.forEach((name, i) => {
        const shortName = `T${i + 1}`;
        headers.push(`${shortName} Eff%`, `${shortName} CV%`);
    });
    
    let xPos = tableStartX;
    headers.forEach((header, i) => {
        // å‚ç›´åˆ†éš”ç·š
        if (i > 0) {
            doc.setDrawColor(255, 255, 255);
            doc.setLineWidth(0.5);
            doc.line(xPos, yPos, xPos, yPos + 12);
        }
        
        // æ–‡å­—å±…ä¸­å°é½Š
        const textWidth = doc.getTextWidth(header);
        const textX = xPos + (colWidth - textWidth) / 2;
        doc.text(header, textX, yPos + 8);
        xPos += colWidth;
    });
    
    yPos += 12;
    doc.setFont(undefined, 'normal');
    
    // æ•¸æ“šè¡Œ
    const maxRows = Math.min(N, 30); // å¢åŠ é¡¯ç¤ºè¡Œæ•¸
    for (let i = 0; i < maxRows; i++) {
        // æª¢æŸ¥æ˜¯å¦éœ€è¦æ›é 
        if (yPos + 8 > pageHeight - 30) {
            doc.addPage();
            yPos = margin;
            
            // é‡è¤‡è¡¨é ­
            doc.setFillColor(240, 240, 240);
            doc.rect(tableStartX, yPos, actualTableWidth, 10, 'F');
            doc.setDrawColor(180, 180, 180);
            doc.setLineWidth(0.3);
            doc.rect(tableStartX, yPos, actualTableWidth, 10, 'S');
            
            doc.setFontSize(7);
            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'bold');
            xPos = tableStartX;
            headers.forEach((header, j) => {
                if (j > 0) {
                    doc.line(xPos, yPos, xPos, yPos + 10);
                }
                const textWidth = doc.getTextWidth(header);
                const textX = xPos + (colWidth - textWidth) / 2;
                doc.text(header, textX, yPos + 7);
                xPos += colWidth;
            });
            yPos += 10;
            doc.setFont(undefined, 'normal');
        }
        
        // äº¤æ›¿è¡ŒèƒŒæ™¯
        if (i % 2 === 1) {
            doc.setFillColor(248, 249, 250);
            doc.rect(tableStartX, yPos, actualTableWidth, 8, 'F');
        }
        
        // è¡Œé‚Šæ¡†
        doc.setDrawColor(220, 220, 220);
        doc.setLineWidth(0.2);
        doc.rect(tableStartX, yPos, actualTableWidth, 8, 'S');
        
        xPos = tableStartX;
        doc.setFontSize(7);
        doc.setTextColor(0, 0, 0);
        
        // æ•¸æ“šå¡«å……
        const rowData = [];
        
        // æ™‚é–“é»
        const timeLabel = labels[i] || `${i + 1}`;
        const englishTimeLabel = timeLabel.replace(/æœˆ/g, 'M').replace(/é€±/g, 'W').replace(/å¤©/g, 'D').replace(/æ—¥/g, 'D');
        rowData.push(englishTimeLabel);
        
        // å°ç…§çµ„æ•¸æ“š
        rowData.push(isFinite(stats.ctrlAvg[i]) ? round2(stats.ctrlAvg[i]).toString() : '-');
        rowData.push(isFinite(stats.ctrlCv[i]) ? round1(stats.ctrlCv[i]).toString() + '%' : '-');
        
        // è™•ç†çµ„æ•¸æ“š
        for (let t = 0; t < T; t++) {
            const eff = stats.eff[t][i];
            const effText = (eff !== null && isFinite(eff)) ? round2(eff).toString() : '-';
            const significant = stats.isSignificant[t][i];
            rowData.push({text: effText, significant: significant});
            rowData.push(isFinite(stats.trCv[t][i]) ? round1(stats.trCv[t][i]).toString() + '%' : '-');
        }
        
        // ç¹ªè£½æ•¸æ“š
        rowData.forEach((data, j) => {
            // å‚ç›´åˆ†éš”ç·š
            if (j > 0) {
                doc.setDrawColor(230, 230, 230);
                doc.setLineWidth(0.1);
                doc.line(xPos, yPos, xPos, yPos + 8);
            }
            
            let displayText = typeof data === 'object' ? data.text : data;
            let isSignificant = typeof data === 'object' ? data.significant : false;
            
            // æ–‡å­—é¡è‰²å’Œæ ¼å¼
            if (isSignificant) {
                doc.setTextColor(220, 20, 20);
                doc.setFont(undefined, 'bold');
                displayText += '*';
            } else {
                doc.setTextColor(0, 0, 0);
                doc.setFont(undefined, 'normal');
            }
            
            // æ–‡å­—å±…ä¸­å°é½Š
            const textWidth = doc.getTextWidth(displayText);
            const textX = xPos + (colWidth - textWidth) / 2;
            doc.text(displayText, textX, yPos + 5);
            
            xPos += colWidth;
        });
        
        yPos += 8;
    }
    
    // è³‡æ–™çœç•¥æç¤º
    if (N > maxRows) {
        yPos += 5;
        doc.setFontSize(8);
        doc.setTextColor(120, 120, 120);
        const omittedText = `... ${N - maxRows} additional time points omitted (see CSV export for complete data)`;
        const omittedWidth = doc.getTextWidth(omittedText);
        doc.text(omittedText, (pageWidth - omittedWidth) / 2, yPos);
    }
    
    // === çµ±è¨ˆæ‘˜è¦ (æ–°é é¢) ===
    doc.addPage();
    yPos = margin;
    
    // æ‘˜è¦æ¨™é¡Œ
    doc.setFillColor(34, 139, 34);
    doc.rect(0, 0, pageWidth, 25, 'F');
    doc.setFontSize(18);
    doc.setTextColor(255, 255, 255);
    const summaryTitle = 'ğŸ“Š SUMMARY STATISTICS';
    const summaryTitleWidth = doc.getTextWidth(summaryTitle);
    doc.text(summaryTitle, (pageWidth - summaryTitleWidth) / 2, 17);
    
    yPos = 40;
    
    // æ¯å€‹è™•ç†çµ„çš„æ‘˜è¦å¡ç‰‡
    names.forEach((name, t) => {
        const validEffs = stats.eff[t].filter(e => e !== null && isFinite(e));
        const significantCount = stats.isSignificant[t].filter(Boolean).length;
        
        if (validEffs.length > 0) {
            checkPageBreak(45);
            
            // å¡ç‰‡é™°å½±æ•ˆæœ
            doc.setFillColor(230, 230, 230);
            doc.roundedRect(margin + 2, yPos + 2, contentWidth, 40, 5, 5, 'F');
            
            // å¡ç‰‡ä¸»é«”
            doc.setFillColor(248, 249, 250);
            doc.setDrawColor(34, 139, 34);
            doc.setLineWidth(1);
            doc.roundedRect(margin, yPos, contentWidth, 40, 5, 5, 'FD');
            
            // è™•ç†çµ„æ¨™é¡Œæ¢
            doc.setFillColor(34, 139, 34);
            doc.roundedRect(margin, yPos, contentWidth, 12, 5, 5, 'F');
            doc.setFillColor(248, 249, 250);
            doc.rect(margin, yPos + 7, contentWidth, 5, 'F');
            
            doc.setFontSize(12);
            doc.setTextColor(255, 255, 255);
            doc.setFont(undefined, 'bold');
            const treatmentName = name.replace(/è™•ç†/g, 'Treatment').replace(/å°ç…§/g, 'Control');
            doc.text(`ğŸ§ª ${treatmentName} (T${t + 1})`, margin + 8, yPos + 8);
            
            // çµ±è¨ˆæ•¸æ“šç¶²æ ¼
            doc.setFontSize(9);
            doc.setFont(undefined, 'normal');
            
            const statsData = [
                ['Average Efficacy:', `${round2(validEffs.reduce((a, b) => a + b, 0) / validEffs.length)}%`, 'ğŸ“ˆ'],
                ['Maximum Efficacy:', `${round2(Math.max(...validEffs))}%`, 'â¬†ï¸'],
                ['Minimum Efficacy:', `${round2(Math.min(...validEffs))}%`, 'â¬‡ï¸'],
                ['Significant Points:', `${significantCount}/${N} (${round1(significantCount/N*100)}%)`, 'âœ¨']
            ];
            
            const cardInnerWidth = contentWidth - 16;
            const statCardWidth = cardInnerWidth / 2 - 5;
            
            statsData.forEach(([label, value, icon], index) => {
                const col = index % 2;
                const row = Math.floor(index / 2);
                const xOffset = col * (statCardWidth + 10);
                const yOffset = row * 12;
                
                // å°å¡ç‰‡èƒŒæ™¯
                doc.setFillColor(255, 255, 255);
                doc.setDrawColor(220, 220, 220);
                doc.setLineWidth(0.3);
                doc.roundedRect(margin + 8 + xOffset, yPos + 15 + yOffset, statCardWidth, 10, 2, 2, 'FD');
                
                // åœ–æ¨™å’Œæ¨™ç±¤
                doc.setTextColor(80, 80, 80);
                doc.text(`${icon} ${label}`, margin + 12 + xOffset, yPos + 21 + yOffset);
                
                // æ•¸å€¼ (å³å°é½Š)
                doc.setTextColor(34, 139, 34);
                doc.setFont(undefined, 'bold');
                const valueWidth = doc.getTextWidth(value);
                doc.text(value, margin + 8 + xOffset + statCardWidth - valueWidth - 4, yPos + 21 + yOffset);
                doc.setFont(undefined, 'normal');
            });
            
            yPos += 50;
        }
    });
    
    // === æ–¹æ³•å­¸èªªæ˜å€å¡Š ===
    checkPageBreak(60);
    
    // èªªæ˜å€å¡Š
    doc.setFillColor(240, 248, 255);
    doc.setDrawColor(100, 150, 255);
    doc.setLineWidth(0.5);
    doc.roundedRect(margin, yPos, contentWidth, 55, 5, 5, 'FD');
    
    doc.setFontSize(12);
    doc.setTextColor(0, 100, 200);
    doc.setFont(undefined, 'bold');
    doc.text('ğŸ“– METHODOLOGY & NOTES', margin + 8, yPos + 12);
    
    doc.setFontSize(8);
    doc.setTextColor(60, 60, 60);
    doc.setFont(undefined, 'normal');
    
    const notes = [
        'â€¢ Data Transformation: Square root transformation (X + 0.5)^0.5 applied to all raw counts',
        'â€¢ Efficacy Calculation: (1 - Treatment_mean / Control_mean) Ã— 100%',
        'â€¢ Statistical Test: Two-sample t-test performed for each time point',
        'â€¢ Significance Level: p < 0.05 (marked with * in red color)',
        'â€¢ CV% = Coefficient of Variation = (Standard Deviation / Mean) Ã— 100%',
        'â€¢ Legend: T1, T2, T3... = Treatment groups; Eff% = Efficacy percentage'
    ];
    
    notes.forEach((note, index) => {
        doc.text(note, margin + 12, yPos + 22 + (index * 6));
    });
    
    // é è…³
    yPos = pageHeight - 15;
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    const footerText = `Generated by Control Efficacy Analysis System - ${new Date().toISOString().split('T')[0]}`;
    const footerWidth = doc.getTextWidth(footerText);
    doc.text(footerText, (pageWidth - footerWidth) / 2, yPos);
    
    // ä¿å­˜PDF
    doc.save('Control-Efficacy-Analysis-Report.pdf');
}
    function exportCSV() {
        const cache = window.__calcCache;
        if (!cache) { alert('è«‹å…ˆè¨ˆç®—å†åŒ¯å‡ºã€‚'); return; }
        const { labels, ctrlAvg, stats } = cache;
        const header = ['æ™‚é–“é»', 'å°ç…§å¹³å‡(è½‰æ›å¾Œ)', 'å°ç…§æ¨™æº–å·®', 'å°ç…§è®Šç•°ä¿‚æ•¸(%)'];
        for (let t = 0; t < stats.trAvg.length; t++) {
            header.push(`${getTreatmentNames()[t]} é˜²æ²»ç‡(%)`, `${getTreatmentNames()[t]} è®Šç•°ä¿‚æ•¸(%)`);
        }
        const rows = [header];
        for (let i = 0; i < labels.length; i++) {
            const row = [labels[i], round2(ctrlAvg[i]), round2(stats.ctrlSd[i]), round1(stats.ctrlCv[i])];
            for (let t = 0; t < stats.trAvg.length; t++) {
                const eff = stats.eff[t][i] ?? '';
                const cv = stats.trCv[t][i] ?? '';
                row.push(eff, round1(cv));
            }
            rows.push(row);
        }
        const csv = rows.map(r => r.join(',')).join('\n');
        const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'control-efficacy-stats.csv';
        a.click();
        URL.revokeObjectURL(a.href);
    }
    
   function importCSV(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const text = event.target.result;
                const lines = text.split('\n').map(line => line.trim()).filter(line => line !== '');
                
                if (lines.length < 2) {
                    alert('CSV æ ¼å¼éŒ¯èª¤ï¼Œè«‹ç¢ºä¿æª”æ¡ˆåŒ…å«æ¨™é¡Œè¡Œå’Œè‡³å°‘ä¸€è¡Œæ•¸æ“šã€‚');
                    return;
                }
                
                const header = lines[0].split(',').map(h => h.trim());
                const dataRows = lines.slice(1).map(line => line.split(',').map(cell => cell.trim()));
                
                console.log('Header:', header);
                console.log('Sample data:', dataRows.slice(0, 3));
                
                // æ›´å¯¬é¬†çš„æ ¼å¼æª¢æ¸¬
                if (header.length < 4) {
                    alert('CSVæª”æ¡ˆæ¬„ä½æ•¸é‡å¤ªå°‘ï¼Œè‡³å°‘éœ€è¦æ™‚é–“é»+å°ç…§+è™•ç†çµ„æ¬„ä½ã€‚');
                    return;
                }
                
                // å½ˆæ€§æª¢æ¸¬å°ç…§çµ„æ¬„ä½ (æ”¯æ´å¤šç¨®å‘½å)
                let controlCols = 0;
                const controlKeywords = ['å°ç…§', 'control', 'Control', 'CONTROL', 'ctrl', 'Ctrl', 'CTRL', 'ç©ºç™½', 'blank', 'Blank'];
                
                for (let i = 1; i < header.length; i++) {
                    const headerText = header[i].toLowerCase();
                    const isControl = controlKeywords.some(keyword => 
                        headerText.includes(keyword.toLowerCase()) || 
                        headerText.includes('ck') || 
                        headerText.match(/^(c|ck)\d*[-_]/)
                    );
                    
                    if (isControl) {
                        controlCols++;
                    } else if (controlCols > 0) {
                        // å·²ç¶“æ‰¾åˆ°å°ç…§çµ„æ¬„ä½ï¼Œç¾åœ¨é‡åˆ°éå°ç…§çµ„æ¬„ä½ï¼Œåœæ­¢è¨ˆç®—
                        break;
                    }
                }
                
                // å¦‚æœæ²’æ‰¾åˆ°æ˜ç¢ºçš„å°ç…§çµ„ï¼Œå‡è¨­å‰é¢å¹¾æ¬„æ˜¯å°ç…§çµ„
                if (controlCols === 0) {
                    const totalCols = header.length - 1; // æ‰£é™¤æ™‚é–“é»æ¬„ä½
                    if (totalCols >= 3) {
                        // å‡è¨­æ˜¯ 3é‡è¤‡ å°ç…§ + Nå€‹è™•ç†çµ„Ã—3é‡è¤‡ çš„æ ¼å¼
                        controlCols = 3;
                    } else {
                        controlCols = 1;
                    }
                    console.log(`æœªæ‰¾åˆ°å°ç…§çµ„é—œéµå­—ï¼Œå‡è¨­å‰ ${controlCols} æ¬„ç‚ºå°ç…§çµ„`);
                }
                
                // è¨ˆç®—è™•ç†çµ„æ•¸é‡
                const remainingCols = header.length - 1 - controlCols;
                let treatmentGroups = 1;
                
                if (remainingCols > 0) {
                    // å˜—è©¦æª¢æ¸¬è™•ç†çµ„æ•¸é‡
                    if (remainingCols % controlCols === 0) {
                        treatmentGroups = remainingCols / controlCols;
                    } else {
                        // ä¸èƒ½æ•´é™¤ï¼ŒçŒœæ¸¬å¯èƒ½çš„çµ„åˆ
                        const possibleGroups = Math.floor(remainingCols / controlCols);
                        treatmentGroups = Math.max(1, possibleGroups);
                    }
                }
                
                console.log(`æª¢æ¸¬çµæœ: ${controlCols} å°ç…§é‡è¤‡, ${treatmentGroups} è™•ç†çµ„, æ¯çµ„ç´„ ${Math.floor(remainingCols/treatmentGroups)} é‡è¤‡`);
                
                // æä¾›ç”¨æˆ¶ç¢ºèªé¸é …
                const userConfirm = confirm(
                    `æª¢æ¸¬åˆ°çš„æ ¼å¼ï¼š\n` +
                    `â€¢ å°ç…§çµ„é‡è¤‡æ•¸ï¼š${controlCols}\n` +
                    `â€¢ è™•ç†çµ„æ•¸é‡ï¼š${treatmentGroups}\n` +
                    `â€¢ æ™‚é–“é»æ•¸é‡ï¼š${dataRows.length}\n\n` +
                    `æ˜¯å¦æŒ‰æ­¤æ ¼å¼åŒ¯å…¥ï¼Ÿ\n` +
                    `(é»æ“Š"å–æ¶ˆ"å¯æ‰‹å‹•èª¿æ•´åƒæ•¸å¾Œé‡æ–°åŒ¯å…¥)`
                );
                
                if (!userConfirm) {
                    alert('åŒ¯å…¥å·²å–æ¶ˆã€‚æ‚¨å¯ä»¥å…ˆèª¿æ•´ç•Œé¢ä¸Šçš„åƒæ•¸è¨­å®šï¼Œç„¶å¾Œé‡æ–°åŒ¯å…¥æª”æ¡ˆã€‚');
                    return;
                }
                
                // æ›´æ–°ç•Œé¢åƒæ•¸
                $('#treatments').value = Math.max(1, treatmentGroups);
                $('#replicates').value = Math.max(1, controlCols);
                $('#timepoints').value = dataRows.length;
                
                // é‡å»ºç•Œé¢
                buildInputs();
                
                // å¡«å…¥æ•¸æ“š - æ›´å½ˆæ€§çš„æ–¹å¼
                for (let i = 0; i < dataRows.length; i++) {
                    const rowData = dataRows[i];
                    if (rowData.length < 2) continue; // è‡³å°‘è¦æœ‰æ™‚é–“é»+1å€‹æ•¸æ“š
                    
                    // å¡«å…¥å°ç…§çµ„æ•¸æ“š
                    for (let r = 1; r <= controlCols && r < rowData.length; r++) {
                        const input = document.querySelector(`#ctrl_${i + 1}_${r}`);
                        if (input && rowData[r] && rowData[r] !== '') {
                            // å˜—è©¦è½‰æ›ç‚ºæ•¸å­—
                            const numValue = parseFloat(rowData[r]);
                            input.value = isNaN(numValue) ? rowData[r] : numValue;
                        }
                    }
                    
                    // å¡«å…¥è™•ç†çµ„æ•¸æ“š
                    let colIndex = controlCols + 1;
                    const actualTreatments = parseInt($('#treatments').value);
                    const actualReplicates = parseInt($('#replicates').value);
                    
                    for (let t = 1; t <= actualTreatments && colIndex < rowData.length; t++) {
                        for (let r = 1; r <= actualReplicates && colIndex < rowData.length; r++) {
                            const input = document.querySelector(`#t${t}_${i + 1}_${r}`);
                            if (input && rowData[colIndex] && rowData[colIndex] !== '') {
                                const numValue = parseFloat(rowData[colIndex]);
                                input.value = isNaN(numValue) ? rowData[colIndex] : numValue;
                            }
                            colIndex++;
                        }
                    }
                }
                
                alert(`CSVæª”æ¡ˆåŒ¯å…¥æˆåŠŸï¼\nåŒ¯å…¥äº† ${dataRows.length} å€‹æ™‚é–“é»çš„æ•¸æ“šã€‚`);
                
            } catch (error) {
                console.error('Import error:', error);
                alert(`åŒ¯å…¥å¤±æ•—ï¼š${error.message}\n\nè«‹æª¢æŸ¥CSVæ ¼å¼ï¼š\n1. ç¬¬ä¸€è¡Œæ‡‰ç‚ºæ¨™é¡Œ\n2. ä½¿ç”¨é€—è™Ÿåˆ†éš”\n3. åŒ…å«æ™‚é–“é»ã€å°ç…§çµ„ã€è™•ç†çµ„æ¬„ä½`);
            } finally {
                e.target.value = '';
            }
        };
        
        reader.onerror = function() {
            alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æå£ã€‚');
        };
        
        reader.readAsText(file, 'UTF-8');
    }

    function downloadPNG() {
        if (!chart) {
            alert('è«‹å…ˆè¨ˆç®—ä¸¦ç¹ªè£½åœ–è¡¨ï¼');
            return;
        }
        const a = document.createElement('a');
        a.href = chart.toBase64Image();
        a.download = 'efficacy-chart.png';
        a.click();
    }
    let chart;
    function clearChart() {
        if (chart) {
            chart.destroy();
        }
    }

    function drawChart(labels, datasets) {
        clearChart();
        const ctx = $('#chartCanvas').getContext('2d');
        const chartType = $('#chartType').value;
        
        const isLightMode = document.body.classList.contains('light-mode');
        const gridColor = isLightMode ? '#E5E7EB' : '#374151';
        const textColor = isLightMode ? '#1F2937' : '#F3F4F6';
        const tooltipBg = isLightMode ? '#f1f5f9' : '#0b1220';
        const tooltipTitle = isLightMode ? '#1f2937' : '#e5e7eb';
        const tooltipBody = isLightMode ? '#6b7280' : '#9ca3af';
        const tooltipBorder = isLightMode ? '#e2e8f0' : '#1f2937';

        let chartDatasets = datasets.map(dataset => ({
            ...dataset,
            backgroundColor: chartType === 'bar' ? dataset.borderColor : 'rgba(0,0,0,0)',
            pointRadius: chartType === 'line' ? 5 : 0
        }));

        chart = new Chart(ctx, {
            type: chartType,
            data: { labels, datasets: chartDatasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: { left: 10, right: 20, top: 20, bottom: 10 }
                },
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: { 
                            boxWidth: 15,
                            color: textColor,
                            font: { size: 14 }
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: tooltipBg,
                        titleColor: tooltipTitle,
                        bodyColor: tooltipBody,
                        borderColor: tooltipBorder,
                        borderWidth: 1,
                        padding: 10,
                        bodyFont: { size: 14 },
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) { label += ': '; }
                                if (context.parsed.y !== null) { label += round2(context.parsed.y) + '%'; }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { 
                            color: gridColor,
                            drawTicks: false
                        },
                        ticks: { color: textColor, font: { size: 14 } },
                        title: { display: true, text: 'æ™‚é–“é»', color: textColor, font: { size: 16 } }
                    },
                    y: {
                        grid: { 
                            color: gridColor,
                            zeroLineColor: gridColor 
                        },
                        ticks: { 
                            color: textColor,
                            font: { size: 14 },
                            callback: function(value) { return value + '%'; }
                        },
                        title: { display: true, text: 'é˜²æ²»ç‡ (%)', color: textColor, font: { size: 16 } },
                        suggestedMin: -10,
                        suggestedMax: 110
                    }
                }
            }
        });
    }

    function fillDemo() {
        if (!$('#tableHost').querySelector('table')) buildInputs();
        const T = parseInt($('#treatments').value) || 1;
        const R = parseInt($('#replicates').value) || 1;
        const N = parseInt($('#timepoints').value) || 1;
        for (let i = 1; i <= N; i++) {
            const baseCtrl = 24 + Math.round(6 * Math.sin(i / 2));
            for (let r = 1; r <= R; r++) $('#ctrl_' + i + '_' + r).value = Math.max(0, Math.round(baseCtrl + (Math.random() * 6 - 3)));
            for (let t = 1; t <= T; t++) {
                for (let r = 1; r <= R; r++) {
                    const drift = (t * 3) + (i * 0.6);
                    const val = Math.max(0, Math.round(baseCtrl - drift + (Math.random() * 6 - 3)));
                    $('#t' + t + '_' + i + '_' + r).value = val;
                }
            }
        }
        compute();
    }

    window.addEventListener('DOMContentLoaded', () => {
        $('#btnBuild').addEventListener('click', buildInputs);
        $('#btnDemo').addEventListener('click', fillDemo);
        $('#btnCalc').addEventListener('click', compute);
        $('#btnImport').addEventListener('click', () => $('#fileInput').click());
        $('#fileInput').addEventListener('change', importCSV);
        $('#btnCSV').addEventListener('click', exportCSV);
$('#btnDemoCSV').addEventListener('click', downloadDemoCSV);
        $('#btnReport').addEventListener('click', exportReport);
        $('#btnPNG').addEventListener('click', downloadPNG);
        $('#treatments').addEventListener('change', buildTreatmentNames);
        $('#chartType').addEventListener('change', () => {
             if (window.__calcCache) {
                drawChart(window.__calcCache.labels, window.__calcCache.datasets);
            }
        });

        $('#themeToggle').addEventListener('click', () => {
            document.body.classList.toggle('light-mode');
            localStorage.setItem('theme', document.body.classList.contains('light-mode') ? 'light' : 'dark');
            if (window.__calcCache) {
                drawChart(window.__calcCache.labels, window.__calcCache.datasets);
            }
        });

        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.body.classList.remove('light-mode');
        } else {
            document.body.classList.add('light-mode');
        }
        buildInputs();
    });
  </script>
</body>
</html>
