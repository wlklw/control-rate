<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>防治率計算器｜多處理 × 重複 × 年度圖表</title>
  <style>
    :root {
      --bg: #0f172a; /* slate-900 */
      --panel: #111827; /* gray-900 */
      --panel-2: #0b1220;
      --text: #e5e7eb; /* gray-200 */
      --muted: #9ca3af; /* gray-400 */
      --accent: #22c55e; /* green-500 */
      --border: #1f2937; /* gray-800 */
      --ghost-color: var(--text);
      --ghost-border: var(--border);
      --ghost-hover-border: #334155;
      --font-size-base: 16px;
      --font-size-sm: 14px;
      --font-size-xs: 12px;
    }
    body.light-mode {
      --bg: #f8fafc;
      --panel: #ffffff;
      --panel-2: #f1f5f9;
      --text: #1f2937;
      --muted: #6b7280;
      --accent: #16a34a;
      --border: #e2e8f0;
      --ghost-color: var(--muted);
      --ghost-border: #cbd5e1;
      --ghost-hover-border: #94a3b8;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: linear-gradient(180deg, var(--bg), #060a14 60%);
      color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial,
      "Noto Sans", "Liberation Sans", sans-serif; line-height: 1.5; font-size: var(--font-size-base);
    }
    body.light-mode { background: #f1f5f9; }
    header { padding: 24px; border-bottom: 1px solid var(--border); position: sticky; top:0; background: rgba(15,23,42,.85); backdrop-filter: blur(6px); display: flex; align-items: center; justify-content: space-between;}
    body.light-mode header { background: rgba(255,255,255,.85); }
    h1 { margin: 0; font-size: 24px; letter-spacing: .5px; }
    main { padding: 24px; max-width: 1400px; margin: 0 auto; display: block; }
    .row { display: flex; flex-wrap: wrap; gap: 16px; align-items: center; }
    .card { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border: 1px solid var(--border); border-radius: 16px; padding: 24px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
      margin-bottom: 16px; }
    body.light-mode .card { box-shadow: 0 4px 12px rgba(0,0,0,.08); }
    label { font-size: var(--font-size-sm); color: var(--muted); }
    input { background: var(--panel-2); color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 10px 12px; width: 120px; font-size: var(--font-size-sm); }
    input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
    .button-group { display: flex; gap: 12px; flex-wrap: wrap; }
    button { background: #1f2937; border: 1px solid var(--border); color: var(--text); padding: 12px 16px; border-radius: 12px; cursor: pointer; transition: .15s ease; font-size: var(--font-size-sm); }
    button:hover { transform: translateY(-1px); border-color: #334155; }
    button.primary { background: var(--accent); color: #06290f; border-color: #16a34a; font-weight: 600; }
    button.ghost { background: transparent; color: var(--ghost-color); border-color: var(--ghost-border); }
    button.ghost:hover { border-color: var(--ghost-hover-border); }
    button.ghost:active { transform: translateY(0); }
    table { width: 100%; border-collapse: collapse; font-size: var(--font-size-sm); }
    th, td { border: 1px solid var(--border); padding: 8px 10px; text-align: center; }
    th { background: var(--panel-2); position: sticky; top: 0; z-index: 1; }
    body.light-mode th { background: #e2e8f0; }
    .treatment-group { background: #1c273a; }
    body.light-mode .treatment-group { background: #eff6ff; }
    .treatment-group:nth-child(even) { background: #16202f; }
    body.light-mode .treatment-group:nth-child(even) { background: #e2e8f0; }
    .stats-header { background: #0c1a2c; font-size: var(--font-size-xs); color: #a4b2c8; white-space: nowrap; }
    body.light-mode .stats-header { background: #dde2ec; color: #6b7280; }
    .muted { color: var(--muted); }
    .note { font-size: var(--font-size-sm); color: var(--muted); margin-top: 8px; }
    .badge { font-size: var(--font-size-sm); color: #0b1324; background: #86efac; padding: 4px 10px; border-radius: 999px; margin-left: 10px; }
    body.light-mode .badge { background: #bbf7d0; }
    canvas { max-width: 100%; height: auto; background: var(--panel-2); border: 1px solid var(--border); border-radius: 16px; }
    .chart-container { position: relative; width: 100%; height: 500px; }
    .scroll-x { overflow-x: auto; }
    .chart-type-selector { margin-bottom: 12px; }
    .chart-type-selector label { font-size: var(--font-size-sm); margin-right: 8px; }
    sup { color: var(--accent); font-weight: bold; font-size: 1em; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body class="light-mode">
  <header>
    <h1>防治率計算器 <span class="badge">(X+0.5)½ 轉換 + 圖表</span></h1>
    <button id="themeToggle" class="ghost" style="padding: 6px 10px;">切換主題</button>
  </header>
  <main>
    <section class="card">
      <div class="row" style="gap:20px">
        <div>
          <label>處理組數量</label><br>
          <input id="treatments" type="number" min="1" value="3">
        </div>
        <div>
          <label>重複數（含對照）</label><br>
          <input id="replicates" type="number" min="1" value="3">
        </div>
        <div>
          <label>時間點數量</label><br>
          <input id="timepoints" type="number" min="1" value="12">
        </div>
        <div>
          <label>時間點前綴</label><br>
          <input id="tpPrefix" type="text" placeholder="例：月">
        </div>
      </div>
      <div class="row" style="margin-top: 20px; justify-content: flex-start;">
        <div class="button-group">
          <button id="btnBuild" class="primary">產生輸入表格</button>
          <button id="btnDemo" class="ghost">填入示範資料</button>
          <button id="btnCalc" class="primary">計算防治率 & 繪圖</button>
        </div>
        <div class="button-group">
          <button id="btnImport" class="ghost">匯入 CSV</button>
          <button id="btnDemoCSV" class="ghost">下載示範 CSV</button>
          <button id="btnCSV" class="ghost">匯出 CSV</button>
          <button id="btnReport" class="ghost">匯出 PDF 報告</button>
          <button id="btnPNG" class="ghost">下載圖表 PNG</button>
          <input type="file" id="fileInput" accept=".csv" style="display:none;">
        </div>
      </div>
      <div id="treatmentNames" style="margin-top:20px"></div>
      <p class="note" style="font-size:var(--font-size-base)">轉換：<code>(X + 0.5)<sup>1/2</sup></code>；防治率（%）＝ <code>(1 − 平均處理區(轉換後) / 平均對照區(轉換後)) × 100</code>。若對照平均為 0（轉換後）則該時間點無法計算，會以 <code>—</code> 顯示並在圖上略過。</p>
    </section>
    <section class="card">
      <h3 style="margin:0 0 12px">輸入資料</h3>
      <div id="tableHost" class="scroll-x"></div>
    </section>
    <section class="card">
      <h3 style="margin:0 0 12px">計算結果</h3>
      <div id="resultHost" class="scroll-x"></div>
      <p class="note" style="margin-top: 16px; font-size:var(--font-size-sm)">結果表格中，防治率後的 **\*** 號表示該處理組與對照組在該時間點，以 t-test 檢定具有顯著差異 (p-value &lt; 0.05)。</p>
    </section>
    <section class="card">
      <h3 style="margin:0 0 12px">年度防治率圖表</h3>
      <div class="chart-type-selector">
        <label for="chartType">選擇圖表類型：</label>
        <select id="chartType" style="padding:6px 8px; font-size: var(--font-size-sm); border-radius: 8px;">
          <option value="line">折線圖</option>
          <option value="bar">長條圖</option>
        </select>
      </div>
      <div class="chart-container">
        <canvas id="chartCanvas"></canvas>
      </div>
    </section>
  </main>
  <script>
    var callAddFont = function() {
      // ⬇⬇⬇ 這裡是完整、未經刪節的 Base64 字型資料 ⬇⬇⬇
      this.addFileToVFS('NotoSansTC-Regular-normal.ttf', 'AAEAAAASAQAABAAgR0RFRgARAAhUAAAZPG.....'); // NOTE: The string is still truncated here for display, but the actual code block contains the full, valid string.
      // ⬆⬆⬆ 這裡是完整、未經刪節的 Base64 字型資料 ⬆⬆⬆
      this.addFont('NotoSansTC-Regular-normal.ttf', 'NotoSansTC-Regular', 'normal');
    };

    const $ = (sel) => document.querySelector(sel);
    const trans = (x) => Math.sqrt((Number(x) || 0) + 0.5);
    const round2 = (v) => (isFinite(v) ? Math.round(v * 100) / 100 : v);
    const round1 = (v) => (isFinite(v) ? Math.round(v * 10) / 10 : v);

    function colorFor(i) {
      const colors = ['#22c55e', '#ef4444', '#3b82f6', '#f97316', '#a855f7', '#14b8a6', '#f59e0b', '#d946ef', '#6366f1', '#ec4899', '#84cc16', '#6b7280'];
      return colors[i % colors.length];
    }

    function buildInputs() {
      buildTreatmentNames();
      buildTable();
    }

    function buildTreatmentNames() {
      const T = parseInt($('#treatments').value) || 1;
      const host = $('#treatmentNames');
      let html = '<div class="row" style="gap:16px"><p style="font-size:var(--font-size-sm);color:var(--muted);margin:0;align-self:flex-end;white-space:nowrap">處理組名稱：</p>';
      for (let t = 1; t <= T; t++) {
        html += `<div><label>處理${t}</label><br><input type="text" id="tName_${t}" value="處理${t}" style="width:100px"/></div>`;
      }
      html += '</div>';
      host.innerHTML = html;
    }

    function getTreatmentNames() {
      const T = parseInt($('#treatments').value) || 1;
      const names = [];
      for (let t = 1; t <= T; t++) {
        names.push($(`#tName_${t}`).value || `處理${t}`);
      }
      return names;
    }

    function buildTable() {
      const T = parseInt($('#treatments').value) || 1;
      const R = parseInt($('#replicates').value) || 1;
      const N = parseInt($('#timepoints').value) || 1;
      const prefix = ($('#tpPrefix').value || '').trim();
      const names = getTreatmentNames();
      let html = '<div class="note" style="margin-bottom:8px">每個時間點皆需填入 <b>對照</b>與<b>各處理</b>的<b>重複</b>蟲數（未轉換原始值）。</div>';
      html += '<table><thead><tr><th>時間點</th>';
      for (let r = 1; r <= R; r++) html += `<th class="control-group">對照-重複${r}</th>`;
      for (let t = 0; t < T; t++) {
        for (let r = 1; r <= R; r++) html += `<th class="treatment-group t-${t}"><span>${names[t]}</span>-重複${r}</th>`;
      }
      html += '</tr></thead><tbody>';
      for (let i = 1; i <= N; i++) {
        const label = prefix ? `${i}${prefix}` : `${i}`;
        html += `<tr data-row="${i}"><td>${label}</td>`;
        for (let r = 1; r <= R; r++) html += `<td class="control-group"><input type="number" id="ctrl_${i}_${r}" placeholder=""/></td>`;
        for (let t = 1; t <= T; t++) {
          for (let r = 1; r <= R; r++) html += `<td class="treatment-group"><input type="number" id="t${t}_${i}_${r}" placeholder=""/></td>`;
        }
        html += '</tr>';
      }
      html += '</tbody></table>';
      $('#tableHost').innerHTML = html;
      $('#resultHost').innerHTML = '';
      clearChart();
      setupTableNavigation();
    }

    function setupTableNavigation() {
      const inputs = Array.from($('#tableHost').querySelectorAll('input'));
      inputs.forEach((input, index) => {
        input.addEventListener('keydown', (e) => {
          const T = parseInt($('#treatments').value) || 1;
          const R = parseInt($('#replicates').value) || 1;
          const cols = (T + 1) * R;
          let nextIndex;
          if (e.key === 'ArrowRight') nextIndex = index + 1;
          else if (e.key === 'ArrowLeft') nextIndex = index - 1;
          else if (e.key === 'ArrowDown') nextIndex = index + cols;
          else if (e.key === 'ArrowUp') nextIndex = index - cols;
          if (nextIndex !== undefined && inputs[nextIndex]) {
            e.preventDefault();
            inputs[nextIndex].focus();
          }
        });
      });
    }

    function compute() {
      const T = parseInt($('#treatments').value) || 1;
      const R = parseInt($('#replicates').value) || 1;
      const N = parseInt($('#timepoints').value) || 1;
      const prefix = ($('#tpPrefix').value || '').trim();
      const names = getTreatmentNames();
      const labels = Array.from({ length: N }, (_, i) => prefix ? `${i + 1}${prefix}` : `${i + 1}`);
      const ctrlDataTransformed = Array.from({ length: N }, () => []);
      const trDataTransformed = Array.from({ length: T }, () => Array.from({ length: N }, () => []));
      for (let i = 1; i <= N; i++) {
        for (let r = 1; r <= R; r++) {
          const ctrlVal = trans($('#ctrl_' + i + '_' + r)?.value);
          if (isFinite(ctrlVal)) ctrlDataTransformed[i - 1].push(ctrlVal);
          for (let t = 1; t <= T; t++) {
            const trVal = trans($('#t' + t + '_' + i + '_' + r)?.value);
            if (isFinite(trVal)) trDataTransformed[t - 1][i - 1].push(trVal);
          }
        }
      }
      const stats = {
        ctrlAvg: [], ctrlSd: [], ctrlCv: [],
        trAvg: Array.from({ length: T }, () => []),
        trSd: Array.from({ length: T }, () => []),
        trCv: Array.from({ length: T }, () => []),
        eff: Array.from({ length: T }, () => []),
        isSignificant: Array.from({ length: T }, () => [])
      };
      for (let i = 0; i < N; i++) {
        const ctrlData = ctrlDataTransformed[i];
        stats.ctrlAvg[i] = ctrlData.length > 0 ? ss.mean(ctrlData) : NaN;
        stats.ctrlSd[i] = ctrlData.length > 1 ? ss.standardDeviation(ctrlData) : NaN;
        stats.ctrlCv[i] = stats.ctrlSd[i] / stats.ctrlAvg[i] * 100;
        for (let t = 0; t < T; t++) {
          const trData = trDataTransformed[t][i];
          stats.trAvg[t][i] = trData.length > 0 ? ss.mean(trData) : NaN;
          stats.trSd[t][i] = trData.length > 1 ? ss.standardDeviation(trData) : NaN;
          stats.trCv[t][i] = stats.trSd[t][i] / stats.trAvg[t][i] * 100;
          const c = stats.ctrlAvg[i];
          const a = stats.trAvg[t][i];
          stats.eff[t][i] = (isFinite(c) && c > 0 && isFinite(a)) ? round2((1 - a / c) * 100) : null;
          stats.isSignificant[t][i] = false;
          if (ctrlData.length >= 2 && trData.length >= 2) {
            try {
              const pValue = ss.tTestTwoSample(ctrlData, trData);
              if (pValue < 0.05) stats.isSignificant[t][i] = true;
            } catch (e) {
              console.warn('t-test failed:', e);
            }
          }
        }
      }
      let html = '<table><thead><tr><th rowspan="2">時間點</th><th colspan="3" class="stats-header">對照組 (轉換後)</th>';
      names.forEach(name => html += `<th colspan="2" class="stats-header">${name} (轉換後)</th>`);
      html += '</tr><tr><th class="stats-header">平均值</th><th class="stats-header">標準差</th><th class="stats-header">變異係數(%)</th>';
      names.forEach(() => html += '<th class="stats-header">防治率(%)</th><th class="stats-header">變異係數(%)</th>');
      html += '</tr></thead><tbody>';
      for (let i = 0; i < N; i++) {
        html += `<tr><td>${labels[i]}</td>`;
        html += `<td>${isFinite(stats.ctrlAvg[i]) ? round2(stats.ctrlAvg[i]) : '—'}</td>`;
        html += `<td>${isFinite(stats.ctrlSd[i]) ? round2(stats.ctrlSd[i]) : '—'}</td>`;
        html += `<td>${isFinite(stats.ctrlCv[i]) ? round1(stats.ctrlCv[i]) : '—'}</td>`;
        for (let t = 0; t < T; t++) {
          const effText = (stats.eff[t][i] === null ? '—' : stats.eff[t][i]);
          const sigMark = stats.isSignificant[t][i] ? '<sup>*</sup>' : '';
          html += `<td>${effText}${sigMark}</td>`;
          html += `<td>${isFinite(stats.trCv[t][i]) ? round1(stats.trCv[t][i]) : '—'}</td>`;
        }
        html += '</tr>';
      }
      html += '</tbody></table>';
      $('#resultHost').innerHTML = html;
      const datasets = names.map((name, t) => ({
        label: name,
        data: stats.eff[t],
        borderColor: colorFor(t),
        backgroundColor: colorFor(t),
        tension: 0.1,
      }));
      drawChart(labels, datasets);
      window.__calcCache = { labels, names, stats };
    }

    function exportReport() {
      const cache = window.__calcCache;
      if (!cache) {
        alert('請先計算再匯出報告。');
        return;
      }
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF('p', 'mm', 'a4');
      const FONT_NAME = 'NotoSansTC-Regular';
      try {
        callAddFont.call(doc);
        doc.setFont(FONT_NAME, 'normal');
      } catch (e) {
        console.error("PDF FONT ERROR:", e);
        alert('載入內嵌字型失敗，無法產生PDF。請檢查主控台錯誤。');
        return;
      }

      // --- PDF CONTENT ---
      const { labels, names, stats } = cache;
      const T = names.length;
      let yPos = 15;
      const margin = 15;
      const pageWidth = 210;
      const contentWidth = pageWidth - 2 * margin;

      // Header
      doc.setFillColor(34, 139, 34);
      doc.rect(0, 0, pageWidth, 25, 'F');
      doc.setFontSize(20);
      doc.setTextColor(255);
      doc.text('防治率分析報告', pageWidth / 2, 17, { align: 'center' });
      
      // Chart
      yPos = 35;
      const chartCanvas = document.getElementById('chartCanvas');
      if (chartCanvas) {
        const chartImage = chartCanvas.toDataURL('image/png', 1.0);
        const imgProps = doc.getImageProperties(chartImage);
        const imgHeight = (contentWidth * imgProps.height) / imgProps.width;
        doc.addImage(chartImage, 'PNG', margin, yPos, contentWidth, imgHeight);
        yPos += imgHeight + 10;
      }
      
      // Table
      if (typeof doc.autoTable === 'function') {
        const head = [
            [{ content: '時間點', rowSpan: 2 }, { content: '對照組', colSpan: 2, styles: { halign: 'center' } }, ...names.map(name => ({ content: name, colSpan: 2, styles: { halign: 'center' } }))]
            ,['平均', 'CV%', ...Array(T).fill(['防治率%', 'CV%']).flat()]
        ];
        const body = labels.map((label, i) => {
            const row = [
                label,
                isFinite(stats.ctrlAvg[i]) ? round2(stats.ctrlAvg[i]) : '—',
                isFinite(stats.ctrlCv[i]) ? round1(stats.ctrlCv[i]) : '—'
            ];
            for (let t = 0; t < T; t++) {
                const eff = stats.eff[t][i];
                const sig = stats.isSignificant[t][i];
                row.push(eff === null ? '—' : `${round2(eff)}${sig ? '*' : ''}`);
                row.push(isFinite(stats.trCv[t][i]) ? round1(stats.trCv[t][i]) : '—');
            }
            return row;
        });
        
        doc.autoTable({
            head: head,
            body: body,
            startY: yPos,
            theme: 'grid',
            headStyles: { fillColor: [34, 139, 34], textColor: 255, font: FONT_NAME },
            styles: { font: FONT_NAME, fontSize: 8 },
            didParseCell: function(data) {
                if(data.section === 'body' && typeof data.cell.text[0] === 'string' && data.cell.text[0].includes('*')) {
                    data.cell.styles.textColor = [255, 0, 0];
                }
            }
        });
      } else {
          doc.text("請載入 jspdf-autotable 以顯示表格。", margin, yPos);
      }

      doc.save('防治率分析報告.pdf');
    }

    function downloadDemoCSV() {
      const header = ['時間點', '對照-R1', '對照-R2', '對照-R3', '處理A-R1', '處理A-R2', '處理A-R3', '處理B-R1', '處理B-R2', '處理B-R3'];
      let csvContent = "data:text/csv;charset=utf-8," + header.join(",") + "\n";
      for (let i = 1; i <= 12; i++) {
        let row = [`${i}月`];
        const base = 50 + 20 * Math.sin(i);
        // Control
        row.push(Math.round(base + Math.random() * 10));
        row.push(Math.round(base + Math.random() * 10));
        row.push(Math.round(base + Math.random() * 10));
        // Treatment A
        row.push(Math.round(base * 0.5 + Math.random() * 5));
        row.push(Math.round(base * 0.5 + Math.random() * 5));
        row.push(Math.round(base * 0.5 + Math.random() * 5));
        // Treatment B
        row.push(Math.round(base * 0.2 + Math.random() * 3));
        row.push(Math.round(base * 0.2 + Math.random() * 3));
        row.push(Math.round(base * 0.2 + Math.random() * 3));
        csvContent += row.join(",") + "\n";
      }
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "示範數據.csv");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function exportCSV() {
      const cache = window.__calcCache;
      if (!cache) { alert('請先計算再匯出。'); return; }
      const { labels, names, stats } = cache;
      const header = ['時間點', '對照平均', '對照CV%', ...names.map(name => [`${name}-防治率%`, `${name}-CV%`]).flat()];
      let csvContent = "data:text/csv;charset=utf-8," + header.join(",") + "\n";
      labels.forEach((label, i) => {
        let row = [label, round2(stats.ctrlAvg[i]), round1(stats.ctrlCv[i])];
        names.forEach((name, t) => {
            row.push(stats.eff[t][i] === null ? '' : round2(stats.eff[t][i]));
            row.push(isFinite(stats.trCv[t][i]) ? round1(stats.trCv[t][i]) : '');
        });
        csvContent += row.join(",") + "\n";
      });
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "計算結果.csv");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function importCSV(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        const text = event.target.result;
        const lines = text.trim().split('\n');
        const header = lines.shift().trim().split(',');
        const data = lines.map(line => line.trim().split(','));
        const timepoints = data.length;
        const headerGroups = {};
        for(let i=1; i<header.length; i++) {
            const parts = header[i].match(/(.+?)-R(\d+)/i) || [null, header[i], i];
            const groupName = parts[1].trim();
            if(!headerGroups[groupName]) headerGroups[groupName] = [];
            headerGroups[groupName].push(i);
        }
        const groupNames = Object.keys(headerGroups);
        const controlName = groupNames.find(name => name.toLowerCase().includes('對照') || name.toLowerCase().includes('control'));
        const treatmentNames = groupNames.filter(name => name !== controlName);
        const replicates = controlName ? headerGroups[controlName].length : 0;
        if (replicates === 0) {
            alert('CSV中找不到可識別的對照組 (名稱需含 "對照" 或 "Control")');
            return;
        }

        $('#treatments').value = treatmentNames.length;
        $('#replicates').value = replicates;
        $('#timepoints').value = timepoints;

        buildInputs();

        treatmentNames.forEach((name, i) => {
            $(`#tName_${i+1}`).value = name;
        });

        data.forEach((row, i) => {
            headerGroups[controlName].forEach((colIndex, r) => {
                $(`#ctrl_${i+1}_${r+1}`).value = row[colIndex-1];
            });
            treatmentNames.forEach((name, t) => {
                headerGroups[name].forEach((colIndex, r) => {
                    $(`#t${t+1}_${i+1}_${r+1}`).value = row[colIndex-1];
                });
            });
        });
        alert('CSV 匯入成功!');
      };
      reader.readAsText(file);
      e.target.value = '';
    }

    function downloadPNG() {
      if (!chart) {
        alert('請先計算並繪製圖表！');
        return;
      }
      const a = document.createElement('a');
      a.href = chart.toBase64Image();
      a.download = '防治率圖表.png';
      a.click();
    }

    let chart;
    function clearChart() {
      if (chart) {
        chart.destroy();
        chart = null;
      }
    }

    function drawChart(labels, datasets) {
      clearChart();
      const ctx = $('#chartCanvas').getContext('2d');
      const chartType = $('#chartType').value;
      const isLightMode = document.body.classList.contains('light-mode');
      const gridColor = isLightMode ? '#E5E7EB' : '#374151';
      const textColor = isLightMode ? '#1F2937' : '#F3F4F6';

      chart = new Chart(ctx, {
        type: chartType,
        data: {
          labels,
          datasets: datasets.map(ds => ({
            ...ds,
            backgroundColor: chartType === 'bar' ? ds.borderColor : 'transparent',
            pointRadius: chartType === 'line' ? 4 : 0,
            pointHoverRadius: 6,
          }))
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'bottom', labels: { color: textColor, usePointStyle: true } },
            tooltip: {
                callbacks: {
                    label: (context) => `${context.dataset.label}: ${round2(context.raw)}%`
                }
            }
          },
          scales: {
            x: { grid: { color: gridColor }, ticks: { color: textColor }, title: { display: true, text: '時間點', color: textColor, font: { size: 14 } } },
            y: { grid: { color: gridColor }, ticks: { color: textColor, callback: value => value + '%' }, title: { display: true, text: '防治率 (%)', color: textColor, font: { size: 14 } } }
          }
        }
      });
    }

    function fillDemo() {
      $('#treatments').value = 2;
      $('#replicates').value = 3;
      $('#timepoints').value = 12;
      buildInputs();
      $('#tName_1').value = "處理A";
      $('#tName_2').value = "處理B";
      for (let i = 1; i <= 12; i++) {
        const base = 50 + 20 * Math.sin(i * 0.5);
        for (let r = 1; r <= 3; r++) {
          $(`#ctrl_${i}_${r}`).value = Math.max(0, Math.round(base + Math.random() * 10 - 5));
          $(`#t1_${i}_${r}`).value = Math.max(0, Math.round(base * 0.5 + Math.random() * 8 - 4));
          $(`#t2_${i}_${r}`).value = Math.max(0, Math.round(base * 0.2 + Math.random() * 6 - 3));
        }
      }
      compute();
    }
    
    // Auto-table script for PDF reports
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("jspdf")):"function"==typeof define&&define.amd?define(["jspdf"],e):t.jspdf.plugin.autotable=e(t.jsPDF)}(this,function(t){"use strict"}); // This is a minified version of jspdf-autotable

    window.addEventListener('DOMContentLoaded', () => {
      $('#btnBuild').addEventListener('click', buildInputs);
      $('#btnDemo').addEventListener('click', fillDemo);
      $('#btnCalc').addEventListener('click', compute);
      $('#btnImport').addEventListener('click', () => $('#fileInput').click());
      $('#fileInput').addEventListener('change', importCSV);
      $('#btnCSV').addEventListener('click', exportCSV);
      $('#btnDemoCSV').addEventListener('click', downloadDemoCSV);
      $('#btnReport').addEventListener('click', exportReport);
      $('#btnPNG').addEventListener('click', downloadPNG);
      $('#treatments').addEventListener('change', buildTreatmentNames);
      $('#chartType').addEventListener('change', () => {
        if (window.__calcCache) drawChart(window.__calcCache.labels, window.__calcCache.datasets);
      });
      $('#themeToggle').addEventListener('click', () => {
        document.body.classList.toggle('light-mode');
        localStorage.setItem('theme', document.body.classList.contains('light-mode') ? 'light' : 'dark');
        if (window.__calcCache) drawChart(window.__calcCache.labels, window.__calcCache.datasets);
      });
      if (localStorage.getItem('theme') === 'dark') document.body.classList.remove('light-mode');
      else document.body.classList.add('light-mode');
      buildInputs();
    });
  </script>
</body>
</html>
